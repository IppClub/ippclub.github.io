<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>mongo 源码阅读感悟（一）</title>
    <link href="/mongo-%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB%E6%84%9F%E6%82%9F%EF%BC%88%E4%B8%80%EF%BC%89/"/>
    <url>/mongo-%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB%E6%84%9F%E6%82%9F%EF%BC%88%E4%B8%80%EF%BC%89/</url>
    
    <content type="html"><![CDATA[<p>其实开头的这一篇不完全是阅读 mongo 时的感悟，也包括了我在 leveldb 中学到的技巧。看过 leveldb 的应该都知道，这份代码的注释不算清楚，文档也少，阅读体验不算好，需要 C++ 开发者有足够的经验。因此有些东西我到了mongo才真正了解它们的作用。也是十分惭愧。</p><p>最近在阅读 mongo&#x2F;bson 的源码，我试图去实现一个 bson，在造轮子的过程中学习他们的编程技巧，事实证明阅读大型且较新的项目的源码要远远好过阅读小而老的项目。</p><p>这篇文章我来介绍两个很小的类，<code>Status</code> 和 <code>StringData</code>，<code>StringData</code> 在 leveldb 中是 <code>Slice</code>，为了方便，之后我都会用 <code>Slice</code>。</p><h3 id="Status"><a href="#Status" class="headerlink" title="Status"></a>Status</h3><p>许多大型 C++ 项目的编程规范要求 exception free，在实际的编程中，开发者会发现使用 error 来代替 exception 其实十分实用（golang开发中更多使用 error 而非 exception），因为很多的编程错误被强行放到了 exception 中，比如 java 的 <code>IndexOutOfBoundException</code>。再者，exception 也常常拉低了执行效率。对于不在意性能的语言（比如Java），exception 的罪状更多的在于如果不将异常及时catch，exception会蔓延到外部。</p><p>这里我们介绍一个设施，它可以保证错误只会被手动的抛到外部，甚至我们可以保存错误的状态，延迟抛出（异常能做这件事吗？）。</p><p>在 mongo 和 leveldb 中，都用了 Status 封装错误信息。</p><p>Status 封装了 enum 类型的错误码，并且可以为每个错误绑定它的具体错误信息。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">static</span> Status <span class="hljs-title">FailedToParse</span><span class="hljs-params">(<span class="hljs-type">const</span> Slice &amp;msg)</span></span>;<br></code></pre></td></tr></table></figure><p>一个 FailedToParse 错误就可以这样被抛出来。</p><p>为了节约内存，enum 被转为 <code>unsigned char</code>，用以存储至多 256 种错误。当然，大型项目可以多于这个数。</p><p><code>Status::OK()</code> 表示这个函数调用没有错误，跟 C 语言里返回值为 0 类似，Status 通常也是通过函数返回值抛出。我们要尽量使得成功的函数调用几乎无需处理错误，只有在错误发生的时候才去处理错误。因此我们这样实现：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Status</span> &#123;<br> <span class="hljs-keyword">private</span>:<br>  std::unique_ptr&lt;ErrorInfo&gt; info_;<br>&#125;;<br></code></pre></td></tr></table></figure><p><code>Status</code> 内部只保存指向错误信息的指针。<code>Status::OK()</code> 抛出一个未初始化的指针（指向 null），只有在错误的信息抛出时，才会生成信息给指针。</p><h3 id="Slice"><a href="#Slice" class="headerlink" title="Slice"></a>Slice</h3><p><code>Slice</code> 是对字符串的一种简单的 reference 的封装，它仅保存字符串的指针（<code>char*</code>）和字符串的长度。与 <code>std::string</code> 用途不同，它不会对字符串进行复制操作，在这一点上比 <code>std::string</code> 要好用许多。当然，我们也可以在整个项目中，完全使用 <code>std::string</code>，并且在函数接口中使用 <code>const std::string&amp;</code>，这样在一个需要大量使用字符串的代码中，函数的接口会变得混乱不堪。</p><p>使用了 <code>Slice</code> 之后，我们可以这样编写一个函数的接口。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp">Parser::<span class="hljs-built_in">parseInt</span>(Slice int_string);<br></code></pre></td></tr></table></figure><p>一方面这样可以简化函数接口（如果要 forward declaration 则需要引用），一方面这样可以兼容 raw string 和 <code>std::string</code>，不会出现 raw string 传参给 <code>const std::string &amp;</code> 时，出现复制的情况。</p><p>唯一的缺点是我们需要去重新实现一些基本的工具函数。好在有 <code>&lt;cstring&gt;</code>，使得这一切并不算难。</p><h3 id="附录"><a href="#附录" class="headerlink" title="附录"></a>附录</h3><p>附上我的实现：</p><ul><li><p>Slice: <a href="https://github.com/neverchanje/bson-cpp11/blob/master/src%2FSlice.h">github link</a></p></li><li><p>Status: <a href="https://github.com/neverchanje/bson-cpp11/blob/master/src%2FStatus.h">github link</a></p></li></ul>]]></content>
    
    
    <categories>
      
      <category>未分类</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C++</tag>
      
      <tag>mongo</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>读 leveldb 的感悟 ：Cache的设计</title>
    <link href="/%E8%AF%BB-leveldb-%E7%9A%84%E6%84%9F%E6%82%9F-%EF%BC%9ACache%E7%9A%84%E8%AE%BE%E8%AE%A1/"/>
    <url>/%E8%AF%BB-leveldb-%E7%9A%84%E6%84%9F%E6%82%9F-%EF%BC%9ACache%E7%9A%84%E8%AE%BE%E8%AE%A1/</url>
    
    <content type="html"><![CDATA[<p>leveldb允许Cache（一个缓冲区的抽象）作为一个Option，用户可以自定义它的实现。具体来说就是这样：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Options</span> &#123;<br>    ...<br>    Cache *block_cache;<br>&#125;;<br></code></pre></td></tr></table></figure><p>这是一个难度较高的设计需求。</p><p>表面上按照逻辑，首先我们定义好Cache的接口，用户可以自行设置Cache的实现，leveldb默认用自己的 <code>ShardedLRUCache</code>（也是LRU Cache的一种）。</p><p>然而我们会遇到几个问题：</p><ol><li><p>Cache无法使用模板，因为它是一个Option。当然，这意味着Cache就是一个包含纯虚函数的接口类。</p></li><li><p>Cache中所存储的key&#x2F;value的value类型不确定，key的类型已知是 string</p></li><li><p>Cache查询时返回一个句柄（Handle），这个Handle应该是什么</p></li><li><p>Handle的内容可以被用户自定义吗？如果是的话，那如何设计？</p></li></ol><p>这几个问题的本质在于Option中无法得到Cache的更多信息，由于模板与继承不同，我们无法使用未指定类型的模板类的指针。简单说就是，我们不能这样写：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp">Cache&lt;K, V&gt; *block_cache;<br></code></pre></td></tr></table></figure><p>在其他一切开源的Cache实现里，Cache通常设计为模板类，他们可以这样：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">template</span> &lt; <span class="hljs-keyword">class</span> <span class="hljs-title class_">TKey</span>, <span class="hljs-keyword">class</span> <span class="hljs-title class_">TValue</span>, <span class="hljs-keyword">class</span> <span class="hljs-title class_">TStrategy</span>&gt;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">AbstractCache</span><br></code></pre></td></tr></table></figure><p>我们通过问题的解决慢慢来解释我们的设计。</p><p>问题2 的解决可以引入 <code>boost::any</code>（其实<code>void*</code>也可以），使用Cache的用户需要知道自己的Value是什么类型，并且要保证自己只加入了一种类型的值。这个做法让我们依然无力控制value的类型。</p><p>问题3  我们定义Handle。Handle 的定义与 Iterator 有区别，Iterator的Concept指出Iterator是一种可以用来遍历容器内每个元素的抽象，而Handle是不可遍历的，我们只能取得Handle所指的元素的值，这点和Iterator一样。</p><p>问题4 Handle 的内容。首先要知道，Handle在一个接口类中定义，那么它本身就无法包含任何信息(It doesn’t carry any properties)。如果是这样，那么它只能是一个 opaque object。或许它可以包含纯虚函数，但与其在Handle中定义，不如在Cache中定义，因为这意味着Handle对象构造时会多一个vptr，而Cache本来已经有vptr了，Handle的纯虚函数定义在Cache中就无所谓，比如说leveldb这样来获取一个Handle所指元素的value的：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-title">Cache::Value</span><span class="hljs-params">(Handle* h)</span> <span class="hljs-type">const</span> </span>= <span class="hljs-number">0</span>;<br></code></pre></td></tr></table></figure><p>其次，Handle的内容并不重要。可以说，Handle是C++的一种设计模式。Handle自身不能做任何事，它只能用来与Cache交互。具体的思路可以参照 windows 的 <code>HWND</code>。其实原理很简单，我们在Cache的子类，例如 LRUCache，实现一个 LRUHandle，它与 <code>Cache::Handle</code> 没有任何继承关系，然后我们只要用 <code>reinterpret_cast&lt;Handle*&gt;</code>就能将 LRUHandle 在内部转为 Handle。</p><p>按照这个思路，Cache的value类型不确定是一个隐患，这是由于Cache是一个Option所导致的。我们要如何设计Cache的抽象？</p><p>Cache的值类型不确定导致它不能像 <code>poco::AbstractCache</code> 或者 guava 的 cache 那样，定义一个全套的Cache所应该有的标准API，它只能作为一个组件来使用，我们采用组合模式来使用它。<br>按照这个思路设计，Cache应该是主要算法的抽象，我们需要将算法，和其他组件一起组装起来才能构成一个真正的Cache，因此，我将leveldb 的Cache改名为 CacheStrategy，由此就符合了我们的设计思路：CacheStrategy 不保证Cache里值的类型都一样，这由Cache来做。</p><p>总结一下我们的设计：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Options</span> &#123;<br>…<br>CacheStategy *block_cache_strategy; <span class="hljs-comment">//</span><br>&#125;;<br></code></pre></td></tr></table></figure><p><code>class CacheStrategy</code> 代替 <code>leveldb::Cache</code>。</p>]]></content>
    
    
    <categories>
      
      <category>未分类</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C++</tag>
      
      <tag>LevelDB</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>C++ 的三种实现接口的方式</title>
    <link href="/C-%E7%9A%84%E4%B8%89%E7%A7%8D%E5%AE%9E%E7%8E%B0%E6%8E%A5%E5%8F%A3%E7%9A%84%E6%96%B9%E5%BC%8F/"/>
    <url>/C-%E7%9A%84%E4%B8%89%E7%A7%8D%E5%AE%9E%E7%8E%B0%E6%8E%A5%E5%8F%A3%E7%9A%84%E6%96%B9%E5%BC%8F/</url>
    
    <content type="html"><![CDATA[<h2 id="传统-interface"><a href="#传统-interface" class="headerlink" title="传统 interface"></a>传统 interface</h2><p>想要实现 interface，在绝大多数 OOP 语言中，会被认为只有一种。如 java 和 C# 的 <code>interface</code> specifier，C++ 的 pure virtual function。通常接口类中强制的不能拥有实现，继承接口的子类至少享有<strong>两个名字</strong>，一个是自身定义的命名，一个是接口名。通常子类转父类（up-cast）在编译期（compile-time）决定，父类转子类（down-cast）在运行时（run-time）决定。</p><p>我们太过于习惯这种接口的方式，而这种接口方式也确实能十分灵活地应用在编程中，以至于我们常常不自觉的在设计中增加不必要的层数。如果你也喜欢 “flat is better than nested” 的理念的话，我接下来将会介绍两种 alternatives，用来代替传统的接口实现。</p><h2 id="Functor"><a href="#Functor" class="headerlink" title="Functor"></a>Functor</h2><p>使用 C 语言同样也可以进行 OOP，思路就是 function pointer。通过注册回调函数，用来替代传统的通过继承来实现接口。 C++11 所提供的<code>std::function</code>，<code>std::bind</code> 和 lambda function 为此提供了极大的便利。</p><h4 id="Example"><a href="#Example" class="headerlink" title="Example"></a>Example</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Comparator</span> &#123;<br> <span class="hljs-keyword">public</span>:<br><br>  <span class="hljs-keyword">typedef</span> std::function&lt;<span class="hljs-type">int</span>(<span class="hljs-type">const</span> Slice &amp;, <span class="hljs-type">const</span> Slice &amp;)&gt; CompareFunc;<br><br>  <span class="hljs-built_in">Comparator</span>(<span class="hljs-type">const</span> CompareFunc &amp;compare_fn) :<br>      <span class="hljs-built_in">compare_</span>(compare_fn)<br>  &#125;<br><br>  <span class="hljs-comment">// Three-way comparison.</span><br>  <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">int</span> <span class="hljs-title">Compare</span><span class="hljs-params">(<span class="hljs-type">const</span> std::string &amp;lhs,</span></span><br><span class="hljs-params"><span class="hljs-function">                      <span class="hljs-type">const</span> std::string &amp;rhs)</span> <span class="hljs-type">const</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">compare_</span>(lhs, rhs);<br>  &#125;<br><br> <span class="hljs-keyword">private</span>:<br>  <span class="hljs-type">const</span> CompareFunc compare_;<br>&#125;;<br></code></pre></td></tr></table></figure><p>每种 <code>Comparator</code> 的示例都可能实现某一种策略(Strategy)。而如果为每一个策略都定义一个子类，会将问题复杂化(flat is better than nested)。</p><h4 id="限制"><a href="#限制" class="headerlink" title="限制"></a>限制</h4><ul><li>所有实例只能拥有父类的名字，不拥有自己的名字。当然设计上也不应该使实例拥有自己的名字。</li></ul><h4 id="适用"><a href="#适用" class="headerlink" title="适用"></a>适用</h4><ul><li><a href="https://en.wikipedia.org/wiki/Strategy_pattern">Strategy Pattern</a></li><li>可以通过<a href="https://en.wikipedia.org/wiki/Decorator_pattern">Decorator Pattern</a>来进行向下扩展。</li></ul><h2 id="CRTP"><a href="#CRTP" class="headerlink" title="CRTP"></a>CRTP</h2><p>所谓接口其实是一种协议，换言之就是，继承接口的子类必须<strong>全部</strong>实现某些功能（函数），由于子类必须不可妥协地全部实现，因此从设计的角度讲，接口的粒度也应该越细越好。</p><p>为了某一个类去实现多个接口，可能不是一种干净的方法，因为这些接口将来可能不一定会被使用。C++ 的设计者为我们提供了无比强大的 template，用来更灵活地设计模块间关系。</p><p>CRTP，即 <a href="https://en.wikipedia.org/wiki/Curiously_recurring_template_pattern">Curiously recurring template pattern</a>。简单说就是将类自身作为自身模板的参数。 <a href="http://www.boost.org/doc/libs/1_54_0/libs/iterator/doc/iterator_facade.html">boost::iterator_facade</a> 就利用了这种方法设计了一个 iterator 的抽象类，我们可以通过继承 <code>boost::iterator_facade</code> 轻易地实现一个 iterator。（吐槽一下，Boost.Iterator 这个库实在是太臃肿了，实际工程上完全可以写一个简易版本）</p><p>我们通过实现一个 <code>IteratorFacade</code> 来介绍这种方法，然而这种方法的实例较长，所以我们分开来讲。</p><h4 id="IteratorFacade"><a href="#IteratorFacade" class="headerlink" title="IteratorFacade"></a>IteratorFacade</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">class</span> <span class="hljs-title class_">Derived</span>, <span class="hljs-keyword">class</span> <span class="hljs-title class_">T</span>&gt;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">IteratorFacade</span> &#123;<br></code></pre></td></tr></table></figure><p>我们自己定义的 <code>Iterator</code> 只要继承 <code>IteratorFacade</code> 就能拥有一堆跟标准库容器一样的细枝末节的功能了（这些功能确实多而且杂）。我们首先假设 <code>Iterator</code>需要是一个 <a href="http://en.cppreference.com/w/cpp/concept/ForwardIterator">forward iterator</a>。</p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs angelscript"><span class="hljs-keyword">class</span> <span class="hljs-symbol">Iterator:</span><br><span class="hljs-symbol">    <span class="hljs-symbol">public</span></span> <span class="hljs-symbol">IteratorFacade</span>&lt;<br>        <span class="hljs-symbol">Iterator,</span><br><span class="hljs-symbol">        <span class="hljs-symbol">int</span>,</span><br><span class="hljs-symbol">        <span class="hljs-symbol">std</span>::<span class="hljs-symbol">forward_iterator_tag</span></span>&gt; &#123;<br><br></code></pre></td></tr></table></figure><p>其中 <code>Derived</code> 参数就是 <code>Iterator</code> 自己了，而 <code>int</code> 对应的 <code>T</code> 参数表示这个 iterator 所指的值。</p><p>现在我们来仔细看看 <code>IteratorFacade</code> 的定义：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">template</span>&lt;<br>    <span class="hljs-keyword">class</span> <span class="hljs-title class_">Derived</span>,<br>    <span class="hljs-keyword">class</span> <span class="hljs-title class_">T</span>,<br>    <span class="hljs-keyword">class</span> <span class="hljs-title class_">Category</span>&gt;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">IteratorFacade</span> &#123;<br> <span class="hljs-keyword">public</span>:<br>  <span class="hljs-keyword">typedef</span> T&amp; Reference;<br>  <span class="hljs-function">Derived <span class="hljs-title">Next</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-function">Derived <span class="hljs-title">tmp</span><span class="hljs-params">(derived())</span></span>;<br>    IteratorCoreAccess::<span class="hljs-built_in">increment</span>(<span class="hljs-built_in">derived</span>());<br>    <span class="hljs-keyword">return</span> tmp;<br>  &#125;<br>  <span class="hljs-function"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">class</span> Facade&gt;</span><br><span class="hljs-function">  <span class="hljs-type">static</span> <span class="hljs-keyword">typename</span> Facade::reference <span class="hljs-title">dereference</span><span class="hljs-params">(Facade <span class="hljs-type">const</span> &amp;f)</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> f.<span class="hljs-built_in">dereference</span>();<br>  &#125;<br>  <span class="hljs-function">Reference <span class="hljs-title">Value</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> IteratorCoreAccess::<span class="hljs-built_in">dereference</span>(<span class="hljs-built_in">derived</span>());<br>  &#125;<br> <span class="hljs-keyword">protected</span>:<br>  <span class="hljs-function">Derived &amp;<span class="hljs-title">derived</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> *<span class="hljs-built_in">static_cast</span>&lt;Derived *&gt;(<span class="hljs-keyword">this</span>);<br>  &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p>这里为了方便，我们使用 <code>Next</code> 而非 <code>operator++</code>（因为 ++ 操作符还分 postfix 和 prefix…），希望阅读到此处的读者不要奇怪。</p><h4 id="实现接口"><a href="#实现接口" class="headerlink" title="实现接口"></a>实现接口</h4><p>我们要在 <code>IteratorFacade</code> 中实现的就是，用户只需实现 <code>increment</code>，<code>dereference</code> 函数，并且将 <code>IteratorCoreAccess</code> 设为友元类，即可实现一个 forward iterator（<code>Next()</code>函数可用）。如果我们想要实现一个 <a href="http://en.cppreference.com/w/cpp/concept/BidirectionalIterator">bidirectional iterator</a>，我们可以实现 <code>decrement</code>，这样 <code>Prev()</code>函数即可用。</p><p>这里的秘密在于 <code>IteratorCoreAccess</code>，由于其中的成员函数用 static 声明，例如只有在 <code>decrement</code> 被调用时，编译器才会去检查 <code>Facade</code> 类型是否具有 member function <code>decrement</code>。</p><figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs perl"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">IteratorCoreAccess</span> </span>&#123;<br>  template&lt;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">D</span>, <span class="hljs-title">class</span> <span class="hljs-title">T</span>, <span class="hljs-title">class</span> <span class="hljs-title">C</span>&gt; <span class="hljs-title">friend</span></span><br><span class="hljs-class">  <span class="hljs-title">class</span> <span class="hljs-title">IteratorFacade</span></span>;<br> private:<br>  template&lt;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Facade</span>&gt;</span><br><span class="hljs-class">  <span class="hljs-title">static</span> <span class="hljs-title">void</span> <span class="hljs-title">increment</span>(<span class="hljs-title">Facade</span> &amp;<span class="hljs-title">f</span>) </span>&#123;<br>    f.increment();<br>  &#125;<br>  template&lt;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Facade</span>&gt;</span><br><span class="hljs-class">  <span class="hljs-title">static</span> <span class="hljs-title">void</span> <span class="hljs-title">decrement</span>(<span class="hljs-title">Facade</span> &amp;<span class="hljs-title">f</span>) </span>&#123;<br>    f.decrement();<br>  &#125;<br>  template&lt;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Facade</span>&gt;</span><br><span class="hljs-class">  <span class="hljs-title">static</span> <span class="hljs-title">typename</span> <span class="hljs-title">Facade</span>::<span class="hljs-title">reference</span> <span class="hljs-title">dereference</span>(<span class="hljs-title">Facade</span> <span class="hljs-title">const</span> &amp;<span class="hljs-title">f</span>) </span>&#123;<br>    <span class="hljs-keyword">return</span> f.dereference();<br>  &#125;<br>  // Objects of this <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">are</span> <span class="hljs-title">useless</span>.</span><br><span class="hljs-class">  <span class="hljs-title">IteratorCoreAccess</span>() = <span class="hljs-title">delete</span></span>;<br>&#125;;<br></code></pre></td></tr></table></figure><p>相对于传统的 interface，这种方法（或者说设计模式）是强耦合的。它提供给用户有限的几种方案，用户根据自身需求（比如需要 forward iterator 还是 bidirectional iterator），实现相应的函数。</p><h4 id="限制-1"><a href="#限制-1" class="headerlink" title="限制"></a>限制</h4><ul><li>这种方法几乎没有多态可言，因为父类的名字不可被使用（由于模板参数的不同，<code>IteratorFacade</code> 的两个子类不一定享有同一个父类）。这导致一定程度上扩展性降低，适用于需求极其稳定的情形。</li><li>不可向下扩展。</li></ul><h4 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h4><ul><li>灵活性强。</li><li>简化了接口的设计。有点像 @叛逆者 曾经在知乎上回答的，<a href="https://www.zhihu.com/question/37208466/answer/71549555">游戏主机效率PC高的回答</a>中提到的，把原先积木拼装结构，变成电焊焊死的，更加结实，也失去了可扩展性。</li></ul>]]></content>
    
    
    <categories>
      
      <category>未分类</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C++</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Swift之AnyClass与动态类型</title>
    <link href="/Swift%E4%B9%8BAnyClass%E4%B8%8E%E5%8A%A8%E6%80%81%E7%B1%BB%E5%9E%8B/"/>
    <url>/Swift%E4%B9%8BAnyClass%E4%B8%8E%E5%8A%A8%E6%80%81%E7%B1%BB%E5%9E%8B/</url>
    
    <content type="html"><![CDATA[<blockquote><p>这次写一下关于Swift中AnyClass的使用以及动态类型的实例化和使用场景</p></blockquote><h1 id="AnyClass与AnyObject"><a href="#AnyClass与AnyObject" class="headerlink" title="AnyClass与AnyObject"></a>AnyClass与AnyObject</h1><p>Swift中，任何自定义的对象都是<code>AnyObject</code>的子类，类似于Java的Object类（但注意，这和Objective-C的NSObject不同，后者在Swift中是专门的UIKit或者AppKit框架里面定义的类型，而非语言所规定的类型）</p><blockquote><p>AnyClass<br>The protocol to which all class types implicitly conform.</p></blockquote><p>Declaration</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs swift"><span class="hljs-keyword">typealias</span> <span class="hljs-type">AnyClass</span> <span class="hljs-operator">=</span> <span class="hljs-type">AnyObject</span>.<span class="hljs-keyword">Type</span><br></code></pre></td></tr></table></figure><blockquote><p>AnyObject</p></blockquote><p>protocol AnyObject { … }</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs swift"><span class="hljs-type">The</span> <span class="hljs-keyword">protocol</span> <span class="hljs-title class_">to</span> which all classes implicitly conform.<br></code></pre></td></tr></table></figure><p>但是注意，这个AnyObject.Type是一个毕竟是一个接口的Property，所以只能在函数的参数里面使用，如果想要直接获取某个类（而非实例）的类型，使用类名.self即可；如果想要获取一个实例的类的类型，使用.dynamicType；对了，如果对象是NSObject的实例（iOS开发中常用），用classForCoder也是一个选择</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs ruby"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Test</span> &#123;&#125;<br>func f(<span class="hljs-symbol">s:</span> <span class="hljs-title class_">AnyClass</span>) &#123;<br>    print(s)<br>&#125;<br>let a = <span class="hljs-title class_">Test</span>.<span class="hljs-variable language_">self</span><br>let b = <span class="hljs-title class_">Test</span>().dynamicType<br>let <span class="hljs-symbol">c:</span><span class="hljs-title class_">AnyClass</span> = <span class="hljs-string">&quot;test&quot;</span>.classForCoder /<span class="hljs-regexp">/注意此时加了classForCoder的方法调用，编译器会推导出&quot;&quot;是一个NSString的实例而不是String</span><br><span class="hljs-regexp">f(a) /</span><span class="hljs-regexp">/Test</span><br><span class="hljs-regexp">f(b) /</span><span class="hljs-regexp">/Test</span><br><span class="hljs-regexp">f(c) /</span><span class="hljs-regexp">/NSString</span><br></code></pre></td></tr></table></figure><h1 id="动态实例化"><a href="#动态实例化" class="headerlink" title="动态实例化"></a>动态实例化</h1><p>既然我们有了某个AnyObject的Type，这样我们就可以直接构造出一个类型的实例。使用AnyObject都有的.init方法即可，当然，AnyObject本身并没有init的构造方法……不过首先，我们得改写Test类的init初始化方法，在前面加上required关键字</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs ruby"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Test</span> &#123;<br>required init()&#123;&#125;<br>&#125;<br>let d = a.init() /<span class="hljs-regexp">/ d is an instance of Test</span><br><span class="hljs-regexp">let e = (c as! NSString.Type).init(stringLiteral: &quot;test&quot;) /</span><span class="hljs-regexp">/ e is &quot;test&quot;</span><br></code></pre></td></tr></table></figure><p>当然，你也许肯定奇怪那个required的init是什么意思，其实这是Swift编译器为了避免出现你使用的这个Test.Type有继承的子类，然后子类的构造函数中使用了这个Type来构造父类这种边界情况出现（考虑的真细……）</p><blockquote><p>Use an initializer expression to construct an instance of a type from that type’s metatype value. For class instances, the initializer that’s called must be marked with the required keyword or the entire class marked with the final keyword.</p></blockquote><p>而且对于一个Protocol，可以用.Protocol来获取这个Protocol的类型（还是AnyClass），也可以用self来统一处理，因为实际上</p><p><code>metatype-type(.self) -&gt; type.Type | type.Protocol</code></p><p>这样的话，有了动态就可以开始干活了</p><h1 id="Swift的反射"><a href="#Swift的反射" class="headerlink" title="Swift的反射"></a>Swift的反射</h1><p>或许你也想，既然我有了动态的类型实例，那么是不是能通过类似Java的反射，获取某个类型的所有Property，然后直接访问这个Property呢？答案也是有的，不过在Swift中很少用到，这里用到到了Mirror</p><blockquote><p>struct Mirror { … }<br>Representation of the sub-structure and optional “display style” of any arbitrary subject instance.</p></blockquote><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs ruby"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Person</span> &#123;<br>    var <span class="hljs-symbol">whatThisProperty:</span><span class="hljs-title class_">String</span><br>    init(<span class="hljs-symbol">name:</span><span class="hljs-title class_">String</span>) &#123;<br>        <span class="hljs-variable language_">self</span>.whatThisProperty = name<br>    &#125;<br>&#125;<br>let p = <span class="hljs-title class_">Person</span>(<span class="hljs-symbol">name:</span> <span class="hljs-string">&quot;Bob&quot;</span>)<br>let mirror = <span class="hljs-title class_">Mirror</span>(<span class="hljs-symbol">reflecting:</span> p)<br>mirror.children.forEach &#123;<br>    print(<span class="hljs-string">&quot;\($0.label!): \($0.value)&quot;</span>) /<span class="hljs-regexp">/ whatThisProperty: Bob</span><br><span class="hljs-regexp">&#125;</span><br></code></pre></td></tr></table></figure><p>这里的children返回的是一个AnyForwardCollection，也是可以像数组一般用index来访问或者forEach遍历的，不过索引顺是序按照你的Property的声明顺序</p><h1 id="最后的小应用"><a href="#最后的小应用" class="headerlink" title="最后的小应用"></a>最后的小应用</h1><p>由于我也不怎么会写iOS，有时候遇到这样一种情况：<br>我提供了一个3D Touch的按钮，四个按钮会对应四种ViewController，iOS提供的API可以获取到用户点击的那个按钮对应的设置的一个字符串值，那么，我可以这样来玩……</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs ruby">/<span class="hljs-regexp">/ 3D Touch 传入的字符串来判断返回某个ViewController</span><br><span class="hljs-regexp">static func shortcutToViewController(type:String) -&gt; UIViewController.Type &#123;</span><br><span class="hljs-regexp">    switch type &#123;</span><br><span class="hljs-regexp">    case &quot;pe&quot;:</span><br><span class="hljs-regexp">        return RunningViewController.self</span><br><span class="hljs-regexp">    case &quot;curriculum&quot;:</span><br><span class="hljs-regexp">        return CurriculumViewController.self</span><br><span class="hljs-regexp">    case &quot;card&quot;:</span><br><span class="hljs-regexp">        return SeuCardViewController.self</span><br><span class="hljs-regexp">    case &quot;nic&quot;:</span><br><span class="hljs-regexp">        return NicViewController.self</span><br><span class="hljs-regexp">    default: return UIViewController.self</span><br><span class="hljs-regexp">    &#125;</span><br><span class="hljs-regexp">&#125;</span><br></code></pre></td></tr></table></figure><p>这是用来判断字符串来产生对应的ViewController.Type的，然后，在真正需要实例化一个新的ViewController来显示一个View的时候，再实例化</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs ruby">func pushToViewController(<span class="hljs-symbol">vc:</span> <span class="hljs-title class_">UIViewController</span>.<span class="hljs-title class_">Type</span>) &#123;<br>    <span class="hljs-regexp">//</span> 确保要显示的<span class="hljs-title class_">ViewController</span>不是顶层显示的<span class="hljs-title class_">ViewController</span><br>    guard let duplication = navigationController?.topViewController?.isKindOfClass(vc) <span class="hljs-keyword">else</span> &#123; <span class="hljs-keyword">return</span> &#125;<br>    <span class="hljs-keyword">if</span> duplication &#123; <span class="hljs-regexp">//</span> 检查失败，重复的<span class="hljs-title class_">ViewController</span>，不需要跳转<br>        <span class="hljs-keyword">return</span><br>    &#125;<br>    let viewController = vc.init(<span class="hljs-symbol">nibName:</span> <span class="hljs-string">&quot;\(vc.classForCoder())&quot;</span>, <span class="hljs-symbol">bundle:</span> <span class="hljs-literal">nil</span>) /<span class="hljs-regexp">/ 初始化ViewController</span><br><span class="hljs-regexp">    navigationController?.pushViewController(viewController, animated: true)</span><br><span class="hljs-regexp">&#125;</span><br></code></pre></td></tr></table></figure><p>这也是一种比较奇怪的方式……不过如果不这样，就会导致在主类和上层里面引入过多的Switch Case或者导致代码中出现纯字符串定义的nibName，这对以后重构非常不利。</p><h1 id="结束语"><a href="#结束语" class="headerlink" title="结束语"></a>结束语</h1><p>嗯，好久没写东西了……主要最近在学编译原理，之后会有几篇讲解通过Java实现一个简单的支持CFG的Yacc(误)的东西……顺便就当复习编译原理的Parser部分了。</p><p>Swift如今开源了：<a href="https://github.com/apple/swift">Swift</a>，不到几天Star就超过了2年出头的Rust(lol)……现如今Star也到了2W5的程度</p><p>虽然UIKit和AppKit这种宝贵的财富Apple肯定不会开源，不过Swift标准库的实现也是越来越完善，而且也有Linux的版本，很多第三方的库开始加入了对Linux的支持（非面向iOS和OS X开发的，比如对SQLite，Redis的wrapper）</p><p>Swift作为一个Rust的对手，一个完全抛弃了C的现代语言，之后在除客户端开发外，更可能的领域就是系统编程和服务端编程了吧。希望能够在在安全性，易用性，效率上达到一个更大的高度，让我们这种开发者也能用的爽，用的顺。</p>]]></content>
    
    
    <categories>
      
      <category>未分类</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Swift</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>我对C++的编程思考</title>
    <link href="/%E6%88%91%E5%AF%B9C-%E7%9A%84%E7%BC%96%E7%A8%8B%E6%80%9D%E8%80%83/"/>
    <url>/%E6%88%91%E5%AF%B9C-%E7%9A%84%E7%BC%96%E7%A8%8B%E6%80%9D%E8%80%83/</url>
    
    <content type="html"><![CDATA[<p>我最近想要这样一个分享平台：它既可以作为我的笔记工具，记录一些文字不太多又不太少的技术知识，又可以作为一个社交平台让别人认识我，让我可以装逼。微博限制字数，朋友圈也不太合适，于是我还是在博客里开一个以后可能会继续更新的文章。现在 I++ 里的博文只有我在做 C++ 的分享，以后如果有人做同样的事情，甚至写了同名的文章，那就可能要给这整个博客做点修改了，比如在博客的 timeline 上加上作者头像和信息，以前一直想做，因为比较懒所以搁置了。</p><h3 id="应该使用-Returned-Value-Optimization-还是-std-move"><a href="#应该使用-Returned-Value-Optimization-还是-std-move" class="headerlink" title="应该使用 Returned Value Optimization 还是 std::move"></a>应该使用 Returned Value Optimization 还是 <code>std::move</code></h3><hr><p>分享一篇我读过的文章 <a href="https://www.ibm.com/developerworks/community/blogs/5894415f-be62-4bc0-81c5-3956e82276f3/entry/RVO_V_S_std_move?lang=zh">RVO V.S. std::move</a></p><p>这里讲到了几个以前我未曾求解的顾虑和疑惑：</p><ul><li><p>C++11 其实已经将 RVO 写在标准中并为大多数编译器支持。这样编写合适的代码就不会再有顾虑了。</p></li><li><p>std::move 的使用场景。实际上 std::move 还是会造成一定的开销，只是相比于复制，移动会更快。</p></li></ul><h3 id="C-使用指针还是创建对象？"><a href="#C-使用指针还是创建对象？" class="headerlink" title="C++ 使用指针还是创建对象？"></a>C++ 使用指针还是创建对象？</h3><hr><p>阅读这篇文章：<a href="http://blog.jobbole.com/90147/">C++中为什么要用指针，而不直接使用对象？</a></p><p>最近写一些代码的时候，仅仅只是因为写的顺了，没经过思考地使用了 <code>std::unique_ptr</code>，现在觉得有些后悔，因为这些地方完全可以用对象代替。但是因为除了代码稍微混乱一些之外，并无伤大雅，所以还在犹豫是否要对他们进行修改。以我现在比较浅薄的经验看来，指针能够让我感觉自然的使用场景大概有这些：</p><ul><li>延迟分配内存（动态分配内存）</li></ul><p>简单的情况是</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-tag">Object</span>  arr<span class="hljs-selector-attr">[100]</span>;<br><span class="hljs-selector-tag">Object</span>* arr<span class="hljs-selector-attr">[100]</span>;<br></code></pre></td></tr></table></figure><p>对比于上下两种情况，后者在数组初始化的时候开销更小，在有些时候是更好的做法。</p><ul><li>用于 forward declaration</li></ul><p>因为 C++ 要求声明对象必须要有类的定义，这就要求必须要 include 相关头文件，为了减少头文件依赖，有时候会用到指针。这种情况也不多。</p><ul><li>shared_ptr</li></ul><p>针对某一内存块会被多个使用者同时使用的情况。</p><ul><li>用于保留容器元素的继承属性</li></ul><p>假如有 <code>B: public A</code> 与集合 <code>std::set&lt;A&gt;</code>。现在我们需要把 B 放入 A 的集合中，在 Java 中，集合内存储的元素依然是 B，而在 C++ 中，编译器会将 B 复制给类型为 A 的集合元素。此时集合内实际存储的是 A。我们希望实现 Java 的效果，就要使用指针。显然 <code>std::unique_ptr</code> 在这里可以发挥作用。</p><p>讲到这里，我想谈一谈我最近遇到的关于 <code>std::unique_ptr</code> 的几个小经历。</p><p>###有关 <code>std::unique_ptr</code> 的编程经历</p><hr><p>语法多如 C++ 的语言总有很多隐形的坑，在编写代码的过程中有时会陷入困境，不知道如何解决，但是山重水复之后，往往会发现柳暗花明的方法。</p><ul><li>在 stl 容器中存储 unique_ptr</li></ul><p>我们以 <code>std::set</code> 来举例。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">template</span> &lt; <span class="hljs-keyword">class</span> <span class="hljs-title class_">T</span>,                        <span class="hljs-comment">// set::key_type/value_type</span><br>           <span class="hljs-keyword">class</span> <span class="hljs-title class_">Compare</span> = less&lt;T&gt;,        <span class="hljs-comment">// set::key_compare/value_compare</span><br>           <span class="hljs-keyword">class</span> Alloc = allocator&lt;T&gt;      <span class="hljs-comment">// set::allocator_type</span><br>           &gt; <span class="hljs-keyword">class</span> set;<br></code></pre></td></tr></table></figure><p>这个接口告诉我们，用户需要在 <code>std::set</code> 声明处定义比较函数 comparator。换句话说，一个 <code>std::set</code> 由两个东西定义，一个是元素类型，一个是元素之间比较的方法（不考虑 allocator）。</p><p>我们其实可以将 comparator 从 set 的定义中解耦出来。实际上 C++ 有多种实现自定义比较的方法。如这篇文章所讲 <a href="http://fusharblog.com/3-ways-to-define-comparison-functions-in-cpp/">3 Ways to Define Comparison Functions in C++</a>。简单说就是通过重载 <code>operator&lt;</code> 来自定义比较方法，这样做就<strong>无需显式定义 comparator</strong>。当然，更多的时候，我还是喜欢显式定义 comparator，这样能更清楚的表明，<strong>一个 set 只允许一种comparator</strong>。</p><p>然而，这与 Java 不同。Java 的模板类型会<a href="http://www.infoq.com/cn/articles/cf-java-generics">在运行时用具体的类型代替</a>。也就是说，给定集合 <code>set&lt;T&gt;</code> 可以代表的不只是 T 的集合，也可以是 T 的子类 SubT1 的集合，SubT2 的集合等等，并且他们之间也互相 compatible（可以直接用等号赋值）。这对面向对象来说是十分自然的一种设计，这意味着当我们将 SubT 继承自 T 之后，我们也同时将 SubT 的 container 继承自 T 的 container。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//Example Code</span><br>TreeSet&lt;E&gt; treeSet = <span class="hljs-keyword">new</span> <span class="hljs-title class_">TreeSet</span>&lt;E&gt;();<br><span class="hljs-type">SubE</span> <span class="hljs-variable">se</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">SubE</span>(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>);<br>treeSet.add(se);<br><span class="hljs-comment">// E 的 print 会输出 E</span><br><span class="hljs-comment">// SubE 的 print 会输出 SubE</span><br><span class="hljs-comment">// 这里输出的是 SubE</span><br>treeSet.first().print();<br></code></pre></td></tr></table></figure><p>而在 C++ 中，我们却需要显式地声明 <code>set&lt;T&gt;</code> 和 <code>set&lt;SubT1&gt;</code>, <code>set&lt;SubT2&gt;</code> … 遇到这个问题，我们可能会开始想到使用 <code>dynamic_cast</code>，然后随即又被<a href="https://www.zhihu.com/question/22445339">它的低效率</a>（见 effective c++ 中的条款27）给吓跑。如果我们想要避免 <code>dynamic_cast</code>，本质上，我们就需要一些 workaround **避免 <code>dynamic_cast</code>**。</p><p>整理一下思路，我们希望能在 <code>std::set</code> 中实现多态（Polymorphism），这其中的核心问题在于实现多态的 comparator。而我们又不希望通过 RTTI 实现 downcast(dynamic_cast)，这意味着，我们<strong>不能直接使用子类 SubT 进行自定义比较</strong>。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">//Example Code</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">A</span> &#123;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-type">int</span> a;<br>&#125;;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">B</span> : <span class="hljs-keyword">public</span> A &#123;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-type">int</span> b;<br>&#125;;<br><br><span class="hljs-keyword">inline</span> <span class="hljs-type">bool</span> <span class="hljs-keyword">operator</span>&lt;(<span class="hljs-type">const</span> std::unique_ptr&lt;A&gt; &amp;i1,<br>  <span class="hljs-type">const</span> std::unique_ptr&lt;A&gt; &amp;i2) &#123;<br><span class="hljs-keyword">return</span> i1-&gt;a &lt; i2-&gt;a;<br>&#125;<br><br><br><span class="hljs-keyword">typedef</span> std::set&lt;std::unique_ptr&lt;A&gt; &gt; ASet;<br></code></pre></td></tr></table></figure><p>上面的代码中，在 <code>ASet</code> 中插入 B 的指针时，不会对属性 <code>b</code> 的值进行比较。简单说，相同 <code>a</code> 值，不同 <code>b</code> 值的 B 会被视作相同。</p><p>排除了几种选择之后，我们可以想到用 virtual function，利用指针保留继承链。最终我使用的方法是<em><strong>留后门</strong></em>：既然不能直接比较 <code>b</code> 的值，就只能绕弯路，<strong>间接地进行比较</strong>。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">A</span> &#123;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-function"><span class="hljs-keyword">virtual</span> boost::any <span class="hljs-title">Others</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> </span>&#123;<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">bool</span> <span class="hljs-title">CompareOthers</span><span class="hljs-params">(<span class="hljs-type">const</span> A&amp; a)</span> <span class="hljs-type">const</span> </span>&#123;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>&#125;<br><br><span class="hljs-type">int</span> a;<br>&#125;;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">B</span> : <span class="hljs-keyword">public</span> A &#123;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-function"><span class="hljs-keyword">virtual</span> boost::any <span class="hljs-title">Others</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> </span>&#123;<br><span class="hljs-keyword">return</span> b;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">bool</span> <span class="hljs-title">CompareOthers</span><span class="hljs-params">(<span class="hljs-type">const</span> A&amp; a)</span> <span class="hljs-type">const</span> </span>&#123;<br><span class="hljs-keyword">return</span> b &lt; boost::<span class="hljs-built_in">any_cast</span>&lt;<span class="hljs-type">int</span>&gt;(rhs.<span class="hljs-built_in">Others</span>());<br>&#125;<br><br><span class="hljs-type">int</span> b;<br>&#125;;<br></code></pre></td></tr></table></figure><p>这里就可以看到我们留后门的两个函数 <code>Others</code> 和 <code>CompareOthers</code>，间接地利用类型转换来实现。最终的自定义比较函数就可以这么写：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">inline</span> <span class="hljs-type">bool</span> <span class="hljs-keyword">operator</span>&lt;(<span class="hljs-type">const</span> std::unique_ptr&lt;A&gt; &amp;i1,<br>  <span class="hljs-type">const</span> std::unique_ptr&lt;A&gt; &amp;i2) &#123;<br><span class="hljs-keyword">if</span>(i1-&gt;a == i2-&gt;a) &#123;<br><span class="hljs-keyword">return</span> i1-&gt;<span class="hljs-built_in">CompareOthers</span>(*i2);<br>&#125;<br><span class="hljs-keyword">return</span> i1-&gt;a &lt; i2-&gt;a;<br>&#125;<br></code></pre></td></tr></table></figure><p>这样我们算是基本完成了需求的实现。</p><p>还有一点。上面我们使用了 <code>boost::any</code> 表示可以接受任何值。这样写比较直观，但是<a href="http://www.nullptr.me/2011/05/10/boostany/"><code>any_cast</code> 的实际性能上貌似与 <code>dynamic_cast</code> 相差不大</a>，都是使用 RTTI。在 benchmark 下，甚至可能出现 <a href="https://felipedelamuerte.wordpress.com/2012/04/06/why-you-shouldnt-use-boostany-especially-not-in-time-critical-code/"><code>boost::any</code> 比 <code>void *</code> 性能相差近50倍的情况</a>。不过这里有充足的优化空间，我们可以完全不必使用 <code>boost::any_cast</code>，而是简单使用 <code>static_cast</code> 就可完成任务。所以这个方法可行。</p><p>看上去，我们好像漂亮地完成了一个（可以不使用 RTTI 的）<a href="https://en.wikipedia.org/wiki/Type_erasure"><em><strong>Type Erasure</strong></em></a>。然而，这意味着我们依然需要使用 downcast 来实现 <em><strong>Type inference</strong></em>，否则，我们的子类 SubT 将无法在任何使用了 <code>std::set&lt;std::unique_ptr&lt;T&gt; &gt;</code> 的地方使用。除非我们可以将 T 与其子类完全地从它们的 caller 中解耦出来，这种方案才有意义。换句话说，我们需要让 caller 完全不必在乎它们使用的类型是 T，还是 SubT1，SubT2，所有的细节都由虚函数来完成。如果可以做到这样，我们就能在不使用 RTTI 的情况下，像 Java 那样完成工作。</p><p>当然，如果使用了 RTTI，那 C++ 和 Java 的区别就很小了。</p><p>多数情况下，我们没有办法不使用 downcast。那么现在问题的核心在于，有没有其他的方法，可以在不使用 RTTI 的前提下，实现 downcast。</p><p>如果在对象较小的情况下，我们可以使用 <a href="http://www.cplusplus.com/forum/articles/18757/"><em><strong>the clone pattern</strong></em></a> 来实现，但在这里不是 clone，我们定义一个 DownCast 函数。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">class</span> <span class="hljs-title class_">T</span>&gt;<br><span class="hljs-keyword">typename</span> std::enable_if&lt;std::is_same&lt;T, B&gt;::value, B&gt;::<span class="hljs-function">type</span><br><span class="hljs-function"><span class="hljs-title">DownCast</span><span class="hljs-params">(<span class="hljs-type">const</span> std::unique_ptr&lt;A&gt; &amp;pA)</span> </span>&#123;<br>  <span class="hljs-function">B <span class="hljs-title">ret</span><span class="hljs-params">(pA-&gt;a, boost::any_cast&lt;<span class="hljs-type">int</span>&gt;(pA-&gt;Others()))</span></span>;<br>  <span class="hljs-keyword">return</span> ret;<br>&#125;<br><br><span class="hljs-comment">// 我们在这里利用复制来进行 downcast，不使用 RTTI</span><br>B b = <span class="hljs-built_in">DownCast</span>&lt;B&gt;(pA);<br></code></pre></td></tr></table></figure><p>当然，我们这里依然假设 <code>boost::any_cast</code> 是一个 exception safe 且 without RTTI 的转换函数。因为我们在这里完全可以优化到这样。</p><p>顺便扔出一个刚刚学会的名词：<a href="https://en.wikipedia.org/wiki/Substitution_failure_is_not_an_error">SFINAE</a></p><hr><h3 id="更新一下"><a href="#更新一下" class="headerlink" title="更新一下"></a>更新一下</h3><p>之前在 <a href="https://felipedelamuerte.wordpress.com/2012/04/06/why-you-shouldnt-use-boostany-especially-not-in-time-critical-code/"><code>boost::any</code> 比 <code>void *</code> 性能相差近50倍</a><br>的链接里，博主提供了测试代码。测试程序测试对基本类型<code>size_t</code>转换所用时长。</p><p>benchmark的结果和我的差不太多。<br>在我的 MacBook Air (13-inch, Early 2014)，clang version 3.6.2 下</p><p>debug mode 的数据是：</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">boost</span>::any - <span class="hljs-number">18</span>.<span class="hljs-number">8269</span><br><span class="hljs-attribute">boost</span>::spirit::hold_any - <span class="hljs-number">3</span>.<span class="hljs-number">50993</span><br><span class="hljs-attribute">void</span> ptr - <span class="hljs-number">0</span>.<span class="hljs-number">860663</span><br></code></pre></td></tr></table></figure><p>release mode 的数据是</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">boost</span>::any - <span class="hljs-number">8</span>.<span class="hljs-number">41195</span><br><span class="hljs-attribute">boost</span>::spirit::hold_any - <span class="hljs-number">0</span>.<span class="hljs-number">499917</span><br><span class="hljs-attribute">void</span> ptr - <span class="hljs-number">0</span>.<span class="hljs-number">043697</span><br></code></pre></td></tr></table></figure><p>公有变量 x 也用了 <code>volatile</code> 修饰，结果应该可靠，可见，<code>boost::any</code> 确实较慢。拖累性能的地方在于exception，可能还因为一部分中间的执行代码，但应该与代码中极少数使用 <code>typeid</code> 的地方无关，知乎上 R大 也曾经解释过，<a href="https://www.zhihu.com/question/38997922/answer/79179526">而当typeid运算符应用在一个指向多态类型对象的指针上的时候，typeid的实现才需要有运行时行为。</a></p><p>所以我们在上面实现 CompareOthers 和 DownCast 的时候，完全可以不用考虑异常，类型转换失败则程序应停止运行而不是抛出异常。</p><hr><p>###C++ 中指针的不便之处</p><p>跑题了很多，将这次的经历归纳在 <code>std::unique_ptr</code> 下更多的是因为，C++ 中指针与对象之间被区分开，这就意味着，<br>我们在判断两个 <code>std::set&lt;std::unique_ptr&lt;A&gt; &gt;</code> 是否相同时，默认对指针进行比较，而不是对对象进行比较。<br>这个时候，我们要为此编写 <code>std::set</code> 的自定义比较函数。</p><p>我们在使用 <code>std::unordered_set&lt;std::unique_ptr&lt;A&gt; &gt;</code> 时也会有相同的问题，同样的，我们也要编写自定义 hasher。</p><p>如果这被 C++ 标准认为是自然的行为的话，那么，我们来看看它会带来的不便之处。</p><p>不便之处在我们使用 <code>std::set&lt;std::set&lt;std::unique_ptr&gt; &gt;</code> 时尤为突出。虽然 <code>unique_ptr</code> 禁止 copy，但是 set<br>是允许 copy 的，这就意味这我们可能需要重新编写 set<unique_ptr> 的复制函数。这让我很疑惑为什么 unique_ptr<br>没有提供默认的 deep copy 接口来复制所指的对象。</p><p>我们为了使用 <code>std::set&lt;std::unique_ptr&gt;</code>，编写了custom comparator。在使用 <code>std::set&lt;std::set&lt;std::unique_ptr&gt; &gt;</code> 时，我们无需再次编写 comparator（stl 为提供 <code>std::set</code> 了 rational operator）。然而，如果我们使用的是 <code>std::unordered_set&lt;std::set&lt;std::unique_ptr&lt;A&gt; &gt; &gt;</code>，我们可能会这么写：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">AHasher</span> &#123;<br>  <span class="hljs-function"><span class="hljs-type">size_t</span></span><br><span class="hljs-function">  <span class="hljs-title">operator</span><span class="hljs-params">()</span><span class="hljs-params">(<span class="hljs-type">const</span> std::set&lt;std::unique_ptr&lt;A&gt; &amp;val)</span> <span class="hljs-type">const</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> boost::<span class="hljs-built_in">hash_value</span>(val);<br>  &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p>这里使用了 <code>boost/functional/hash.hpp</code>。这里看起来合理，但程序运行的时候，我们会发现这与我们预期的不符。这是因为，我们忽略了为 <code>std::unique_ptr&lt;A&gt;</code> 自定义 hasher。这里默认地是对指针的值进行 hash，而不是对对象进行 hash。</p><p>重写一下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">AHasher</span> &#123;<br>  <span class="hljs-function"><span class="hljs-type">size_t</span></span><br><span class="hljs-function">  <span class="hljs-title">operator</span><span class="hljs-params">()</span><span class="hljs-params">(<span class="hljs-type">const</span> std::set&lt;std::unique_ptr&lt;A&gt; &amp;val)</span> <span class="hljs-type">const</span> </span>&#123;<br>    std::<span class="hljs-type">size_t</span> seed = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">const</span> <span class="hljs-keyword">auto</span> &amp;it : val) &#123;<br>      boost::<span class="hljs-built_in">hash_combine</span>(seed, it-&gt;<span class="hljs-built_in">HashValue</span>());<br>    &#125;<br>    <span class="hljs-keyword">return</span> seed;<br>  &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p>原来我们在 set 中存储本来的对象，只需要定义好对象本身的 rational operator 和 copy function，亦或者是 <code>unordered_set</code><br>中的 hasher，就可以很自然地使用了。使用了 <code>unique_ptr</code> 之后，我们还需要重新定义 unique_ptr 的对应函数，才能将 <code>unique_ptr</code> 完全视作对象。</p>]]></content>
    
    
    <categories>
      
      <category>未分类</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C++</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>React-Native -- 下一代UI开发思维</title>
    <link href="/React-Native-%E4%B8%8B%E4%B8%80%E4%BB%A3UI%E5%BC%80%E5%8F%91%E6%80%9D%E7%BB%B4/"/>
    <url>/React-Native-%E4%B8%8B%E4%B8%80%E4%BB%A3UI%E5%BC%80%E5%8F%91%E6%80%9D%E7%BB%B4/</url>
    
    <content type="html"><![CDATA[<h2 id="React-与状态"><a href="#React-与状态" class="headerlink" title="React 与状态"></a>React 与状态</h2><p><code>React.js</code>自从Facebook一推出，就受到Web前端工程师的强烈推崇。虽说曾经火过一时的<code>Angular.js</code>颠覆了前端的工程，但是<code>React</code>更多颠覆的，是下一代UI编程的思维。</p><p>传统UI编程，基本很多地方都需要将数据来源，绑定到对应的UI对象，比如用户点击了一个操作，更改了名称，那么你需要更新执行一个回调函数来处理点击操作，并且把新的数据更新原有的UI对象的属性，比如大概就是这样的东西</p><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs haskell"><span class="hljs-title">func</span> onClick(sender) &#123;<br>var <span class="hljs-class"><span class="hljs-keyword">data</span> = getData(<span class="hljs-title">sender</span>);</span><br>self.button.title = <span class="hljs-class"><span class="hljs-keyword">data</span>.name;</span><br>self.button.color = <span class="hljs-class"><span class="hljs-keyword">data</span>.color;</span><br>&#125;<br></code></pre></td></tr></table></figure><p>这样虽然说直观，但是有很大的问题。试想，假如有很多种的回调函数，每个回调函数监听不同的操作，比如<code>onMounseDown</code>,<code>onMouseUp</code>,<code>onKeyDown</code>,<code>onScroll</code>……甚至根据不同的sender，我们会有不同的操作，我们就必须得手写很多机械的</p><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs haskell"><span class="hljs-title">self</span>.xx = <span class="hljs-class"><span class="hljs-keyword">data</span>.xx</span><br><span class="hljs-title">self</span>.xy = <span class="hljs-class"><span class="hljs-keyword">data</span>.xy</span><br></code></pre></td></tr></table></figure><p>这类的代码，这就给日后维护和扩展带来了灾难，假如我要换一个UI组件，又得一个个检查是否赋值成功；假如我要把这个UI组件在新的UIView里面重用，我又得改动所有的赋值代码，对于大型项目这种UI对象成百上千，UI属性上万，这样是非常可怕的。</p><p>而<code>React</code>，就将所有的赋值，数据绑定，抽象成为一个个状态，不同的事件监听，就是不同的状态而已，而这些状态之间相互独立，不会受到某些全局变量更改而造成UI混乱的情况，更好的是，开发者不需要考虑到底这个属性什么时候赋值，是在数据更新之前还是之后，需不需要定时刷新这种无意义的苦力活上。</p><h2 id="React-Native-示例"><a href="#React-Native-示例" class="headerlink" title="React-Native 示例"></a>React-Native 示例</h2><blockquote><p>完整代码：<a href="https://facebook.github.io/react-native/docs/tutorial.html#content">Tutorial</a></p></blockquote><p>看看<code>React-Native</code>的sample，需求就是实现一个电影列表显示的View。类似这样：</p><p><img src="https://facebook.github.io/react-native/img/TutorialFinal.png" alt="iOS"> <img src="https://facebook.github.io/react-native/img/TutorialFinal2.png" alt="Android"></p><p>这段代码中，只有View和ViewModel（Model就是临时的JSON），React用状态把UI属性和数据绑定起来，从而避免了事件监听手动判断时机来赋值</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> <span class="hljs-title class_">AwesomeProject</span> = <span class="hljs-title class_">React</span>.<span class="hljs-title function_">createClass</span>(&#123;<br>  <span class="hljs-comment">//初始状态，不渲染</span><br>  <span class="hljs-attr">getInitialState</span>: <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-keyword">return</span> &#123;<br>      <span class="hljs-attr">dataSource</span>: <span class="hljs-keyword">new</span> <span class="hljs-title class_">ListView</span>.<span class="hljs-title class_">DataSource</span>(&#123;<br>        <span class="hljs-attr">rowHasChanged</span>: <span class="hljs-function">(<span class="hljs-params">row1, row2</span>) =&gt;</span> row1 !== row2,<br>      &#125;),<br>      <span class="hljs-attr">loaded</span>: <span class="hljs-literal">false</span>,<br>    &#125;;<br>  &#125;,<br><br>  <span class="hljs-comment">//模型层变动导致状态改变，渲染</span><br><br>  <span class="hljs-attr">fetchData</span>: <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-title function_">fetch</span>(<span class="hljs-variable constant_">REQUEST_URL</span>)<br>      .<span class="hljs-title function_">then</span>(<span class="hljs-function">(<span class="hljs-params">response</span>) =&gt;</span> response.<span class="hljs-title function_">json</span>())<br>      .<span class="hljs-title function_">then</span>(<span class="hljs-function">(<span class="hljs-params">responseData</span>) =&gt;</span> &#123;<br>        <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">setState</span>(&#123;<br>          <span class="hljs-attr">dataSource</span>: <span class="hljs-variable language_">this</span>.<span class="hljs-property">state</span>.<span class="hljs-property">dataSource</span>.<span class="hljs-title function_">cloneWithRows</span>(responseData.<span class="hljs-property">movies</span>),<br>          <span class="hljs-attr">loaded</span>: <span class="hljs-literal">true</span>,<br>        &#125;);<br>      &#125;)<br>      .<span class="hljs-title function_">done</span>();<br>  &#125;,<br><br>  <span class="hljs-comment">//渲染层，绑定状态和UI属性</span><br><br>  <span class="hljs-attr">render</span>: <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-keyword">return</span> (<br>      <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">ListView</span>//<span class="hljs-attr">这里是JSX语法</span>，<span class="hljs-attr">在JS里面返回标签</span></span></span><br><span class="hljs-tag"><span class="language-xml">        <span class="hljs-attr">dataSource</span>=<span class="hljs-string">&#123;this.state.dataSource&#125;</span></span></span><br><span class="hljs-tag"><span class="language-xml">        <span class="hljs-attr">renderRow</span>=<span class="hljs-string">&#123;this.renderMovie&#125;</span></span></span><br><span class="hljs-tag"><span class="language-xml">        <span class="hljs-attr">style</span>=<span class="hljs-string">&#123;styles.listView&#125;</span></span></span><br><span class="hljs-tag"><span class="language-xml">      /&gt;</span></span><br>    );<br>  &#125;<br> &#125;<br></code></pre></td></tr></table></figure><blockquote><p>完整代码：<a href="https://github.com/lizhuoli1126/iOS-Demo-Project">iOS Demo</a></p></blockquote><p>相比来说，原生Cocoa Touch的实现，就要丑陋的多了，尤其是渲染部分绑定UI对象的属性和数据来源，假如你有多处数据来源，多种UI属性，你就得写很多判断来保证你的UI对象的属性符合预期的赋值顺序。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">//初始化UI对象，调用模型去获取数据</span><br>override func <span class="hljs-title function_">viewDidLoad</span>(<span class="hljs-params"></span>) &#123;<br>   <span class="hljs-variable language_">super</span>.<span class="hljs-title function_">viewDidLoad</span>()<br>   <span class="hljs-title function_">fetchData</span>()<br>&#125;<br><br><span class="hljs-comment">//获取数据，需要手动维护状态，比如开启indicator(旋转等待条)，数据获取成功后渲染</span><br>func <span class="hljs-title function_">fetchData</span>(<span class="hljs-params"></span>) &#123;<br>   indicator.<span class="hljs-title function_">startAnimating</span>()<br>   <span class="hljs-title function_">request</span>(.<span class="hljs-property">GET</span>, <span class="hljs-variable constant_">API_URL</span>, <span class="hljs-attr">parameters</span>: [<span class="hljs-string">&quot;apikey&quot;</span>: <span class="hljs-variable constant_">API_KEY</span>, <span class="hljs-string">&quot;page_limit&quot;</span>: <span class="hljs-variable constant_">PAGE_SIZE</span>])<br>       .<span class="hljs-property">responseJSON</span>&#123; _, _, data, _ <span class="hljs-keyword">in</span><br>           self.<span class="hljs-title function_">render</span>(<span class="hljs-title class_">JSON</span>(data!))<br>   &#125;<br>&#125;<br><br><span class="hljs-comment">//渲染UI对象，需要手动维护状态，比如关闭indicator(旋转等待条)</span><br>func <span class="hljs-title function_">render</span>(<span class="hljs-params">result:<span class="hljs-built_in">JSON</span></span>) &#123;<br>   indicator.<span class="hljs-title function_">stopAnimating</span>()<br>   movieJSON = result<br>   self.<span class="hljs-property">tableView</span>.<span class="hljs-title function_">reloadData</span>()<br>&#125;<br><br><span class="hljs-comment">//这都算好的了，TableView会自动回调你的代码，返回这个TableView里面的Cell个数</span><br>func <span class="hljs-title function_">tableView</span>(<span class="hljs-attr">tableView</span>: <span class="hljs-title class_">UITableView</span>, numberOfRowsInSection <span class="hljs-attr">section</span>: <span class="hljs-title class_">Int</span>) -&gt; <span class="hljs-title class_">Int</span> &#123;<br>   <span class="hljs-keyword">var</span> movieNum = movieJSON[<span class="hljs-string">&quot;movies&quot;</span>].<span class="hljs-property">arrayValue</span>.<span class="hljs-property">count</span><br>   <span class="hljs-keyword">return</span> movieNum<br>&#125;<br><br><span class="hljs-comment">//可怕的地方，需要手动赋值给UI对象的属性</span><br>func <span class="hljs-title function_">tableView</span>(<span class="hljs-attr">tableView</span>: <span class="hljs-title class_">UITableView</span>, cellForRowAtIndexPath <span class="hljs-attr">indexPath</span>: <span class="hljs-title class_">NSIndexPath</span>) -&gt; <span class="hljs-title class_">UITableViewCell</span> &#123;<br>   <span class="hljs-keyword">let</span> cell = self.<span class="hljs-property">tableView</span>.<span class="hljs-title function_">dequeueReusableCellWithIdentifier</span>(<span class="hljs-string">&quot;movieIdentifier&quot;</span>, <span class="hljs-attr">forIndexPath</span>: indexPath)<br>   <span class="hljs-keyword">as</span>! <span class="hljs-title class_">MovieTableViewCell</span><br><br>   <span class="hljs-keyword">let</span> row = indexPath.<span class="hljs-property">row</span><br><br>   <span class="hljs-comment">//手动维护状态，JSON解析再赋值给对应的UI对象，这里省略了UI对象的代码和样式</span><br>   <span class="hljs-comment">//（一般可以通过Interface Builder做或者专门一个类写UI代码）</span><br>   cell.<span class="hljs-property">movieTitle</span>.<span class="hljs-property">text</span> = movieJSON[<span class="hljs-string">&quot;movies&quot;</span>][row][<span class="hljs-string">&quot;title&quot;</span>].<span class="hljs-property">stringValue</span><br>   cell.<span class="hljs-property">movieYear</span>.<span class="hljs-property">text</span> = movieJSON[<span class="hljs-string">&quot;movies&quot;</span>][row][<span class="hljs-string">&quot;year&quot;</span>].<span class="hljs-property">stringValue</span><br>   <span class="hljs-keyword">var</span> movieImageUrl = movieJSON[<span class="hljs-string">&quot;movies&quot;</span>][row][<span class="hljs-string">&quot;posters&quot;</span>][<span class="hljs-string">&quot;thumbnail&quot;</span>].<span class="hljs-property">stringValue</span><br><br>   <span class="hljs-comment">//最可怕是渲染中还需要新的数据，再回调模型，就很难维护了</span><br>   <span class="hljs-keyword">if</span> cell.<span class="hljs-property">movieImage</span>.<span class="hljs-property">image</span> == nil &#123;<br>       <span class="hljs-title function_">request</span>(.<span class="hljs-property">GET</span>, movieImageUrl).<span class="hljs-property">response</span>&#123; _, _, data, _ <span class="hljs-keyword">in</span><br>           <span class="hljs-keyword">let</span> movieImage = <span class="hljs-title class_">UIImage</span>(<span class="hljs-attr">data</span>: data <span class="hljs-keyword">as</span>! <span class="hljs-title class_">NSData</span>)<br>           cell.<span class="hljs-property">movieImage</span>.<span class="hljs-property">image</span> = movieImage<br>       &#125;<br>   &#125;<br><br>   <span class="hljs-keyword">return</span> cell<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="React-与函数式"><a href="#React-与函数式" class="headerlink" title="React 与函数式"></a>React 与函数式</h1><p><code>React</code>更多的，就是一种类似函数式的想法，把UI对象属性，数据来源，当作一个Monad包裹起来，传统意义上的不同数据来源进行UI属性赋值，相当于这个Monad经过不同的函数作用，达到状态的切换，好处就是大大减少了开发者手动维护UI属性的工作，而且可以达到更高的开发效率。而且再也不怕扩展了，因为这时候可以把多个组件分配给不同的人，每个人完全不需要管别人内部的变量名是什么，UI属性是什么，只要把自己的状态管理好，Model层接口统一，剩下的合并即可。</p><h1 id="React-与效率"><a href="#React-与效率" class="headerlink" title="React 与效率"></a>React 与效率</h1><p>既然提到了状态，因为<code>React</code>采取<code>VirtualDOM</code>来diff需要进行状态更新的UI对象，每次确保了只更新属性发生改变的部分。实现也很高效，使用了一个普通的二叉树<code>vtree</code>。每个结点<code>vnode</code>就是对应的Tag，比如<Image>之类，结点还存储了一个struct用来保存这些Tag的属性（比如Image的size）</p><p>其中的diff算法可以一看……代码地址在：<a href="https://github.com/Matt-Esch/virtual-dom/blob/master/vtree/diff.js">GitHub-vtree</a></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">//主要逻辑，就是对b树进行reorder，找出a树与b树的同结点不同属性的diff</span><br><span class="hljs-comment">//剩下可以无痛patch的部分只需要下面的for循环就可以处理</span><br><span class="hljs-keyword">var</span> aChildren = a.<span class="hljs-property">children</span><br><span class="hljs-keyword">var</span> orderedSet = <span class="hljs-title function_">reorder</span>(aChildren, b.<span class="hljs-property">children</span>)<br><span class="hljs-keyword">var</span> bChildren = orderedSet.<span class="hljs-property">children</span><br><br><span class="hljs-keyword">var</span> len = aLen &gt; bLen ? aLen : bLen<br><br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>; i &lt; len; i++) &#123;<br>   <span class="hljs-keyword">var</span> leftNode = aChildren[i]<br>   <span class="hljs-keyword">var</span> rightNode = bChildren[i]<br>   index += <span class="hljs-number">1</span><br><br>   <span class="hljs-keyword">if</span> (!leftNode) &#123;<br>       <span class="hljs-keyword">if</span> (rightNode) &#123;<br>           <span class="hljs-comment">//这里处理的多余的结点，直接加到b树上即可</span><br>           apply = <span class="hljs-title function_">appendPatch</span>(apply,<br>               <span class="hljs-keyword">new</span> <span class="hljs-title class_">VPatch</span>(<span class="hljs-title class_">VPatch</span>.<span class="hljs-property">INSERT</span>, <span class="hljs-literal">null</span>, rightNode))<br>       &#125;<br>   &#125; <span class="hljs-keyword">else</span> &#123;<br>       <span class="hljs-title function_">walk</span>(leftNode, rightNode, patch, index)<br>   &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>这是核心reorder代码，目标找到是同一结点不同属性的diff，多出来的不需要管</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">//遍历a树，如果b树中结点集合含有a的key，标记下b树中这些key，更新旧的标记</span><br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span> ; i &lt; aChildren.<span class="hljs-property">length</span>; i++) &#123;<br>   <span class="hljs-keyword">var</span> aItem = aChildren[i]<br>   <span class="hljs-keyword">var</span> itemIndex<br><br>   <span class="hljs-keyword">if</span> (aItem.<span class="hljs-property">key</span>) &#123;<br>       <span class="hljs-keyword">if</span> (bKeys.<span class="hljs-title function_">hasOwnProperty</span>(aItem.<span class="hljs-property">key</span>)) &#123;<br>           <span class="hljs-comment">// Match up the old keys</span><br>           itemIndex = bKeys[aItem.<span class="hljs-property">key</span>]<br>           newChildren.<span class="hljs-title function_">push</span>(bChildren[itemIndex])<br><br>       &#125; <span class="hljs-keyword">else</span> &#123;<br>           <span class="hljs-comment">// Remove old keyed items</span><br>           itemIndex = i - deletedItems++<br>           newChildren.<span class="hljs-title function_">push</span>(<span class="hljs-literal">null</span>)<br>       &#125;<br>   &#125;<br>   <span class="hljs-comment">//......</span><br>&#125;<br><br><br><span class="hljs-comment">//遍历b树，添加上面标记的所有key到一个集合，暂时未排序</span><br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> j = <span class="hljs-number">0</span>; j &lt; bChildren.<span class="hljs-property">length</span>; j++) &#123;<br>   <span class="hljs-keyword">var</span> newItem = bChildren[j]<br>   <span class="hljs-keyword">if</span> (newItem.<span class="hljs-property">key</span>) &#123;<br>       <span class="hljs-keyword">if</span> (!aKeys.<span class="hljs-title function_">hasOwnProperty</span>(newItem.<span class="hljs-property">key</span>)) &#123;<br>           newChildren.<span class="hljs-title function_">push</span>(newItem)<br>       &#125;<br>       <span class="hljs-comment">//......</span><br> &#125;<br><br><span class="hljs-comment">//对上述集合，真实的b树删除多余结点，直到上述集合为空为止，复杂度O(n)</span><br><span class="hljs-keyword">var</span> simulate = newChildren.<span class="hljs-title function_">slice</span>()<br><br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> k = <span class="hljs-number">0</span>; k &lt; bChildren.<span class="hljs-property">length</span>;) &#123;<br><span class="hljs-keyword">var</span> wantedItem = bChildren[k]<br>simulateItem = simulate[simulateIndex]<br><br><span class="hljs-comment">//最后删除剩下虚拟的结点</span><br><span class="hljs-keyword">while</span>(simulateIndex &lt; simulate.<span class="hljs-property">length</span>) &#123;<br>   simulateItem = simulate[simulateIndex]<br>   removes.<span class="hljs-title function_">push</span>(<span class="hljs-title function_">remove</span>(simulate, simulateIndex, simulateItem &amp;&amp; simulateItem.<span class="hljs-property">key</span>))<br>&#125;<br></code></pre></td></tr></table></figure><p>整体的时间复杂度，达到了<br>$$ O(M+N) $$<br>已经是理论下界了。比起手动管理状态来说，效率可以说是直接持平，甚至对部分滥用事件监听的写法效率会更高。</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>虽然我并不喜欢UI编程，但是自从图形化出现之后，UI已经成为了继数据结构、算法外，面向终端用户的应用又一个大工程。</p><p>从最早的指令式跳转赋值UI，函数指针响应处理，到中期的面向对象，消息发送回调事件，手动管理属性，在到如今的React以状态和VirualDOM来绑定数据和组件。</p><p>UI编程其实也是在不断进化的，也许今后会有更好的开发方式让我们这群不会写UI的人也能够轻松写起来UI。</p>]]></content>
    
    
    <categories>
      
      <category>未分类</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Swift</tag>
      
      <tag>React-Native</tag>
      
      <tag>IOS</tag>
      
      <tag>Javascript</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Random Binary Search Tree - Treap</title>
    <link href="/Random-Binary-Search-Tree-Treap/"/>
    <url>/Random-Binary-Search-Tree-Treap/</url>
    
    <content type="html"><![CDATA[<h2 id="BST插入顺序与平衡性"><a href="#BST插入顺序与平衡性" class="headerlink" title="BST插入顺序与平衡性"></a>BST插入顺序与平衡性</h2><p>众所周知，二查搜索树(BST)的搜索、插入、删除的复杂度等于树高，所以平衡度越高，越接近$ O(nlogn) $，越有序越退化为$ O(n) $<br><img src="http://opendatastructures.org/ods-java/img2843.png" alt="线性BST"> ……………………<img src="http://opendatastructures.org/ods-java/img2844.png" alt="随机BST"></p><ul><li>对于左侧的BST来说，只有唯一的构造序列：$ &lt;1,2,\dots,14&gt; $</li><li>但对于右侧的BST，可以存在21964800种不同序列</li></ul><p>也就是说，随即插入序列到二叉树所形成的平衡度，将大于部分有序插入所形成的二叉树</p><p>形式化证明可以得到（具体证明过程，参见<a href="http://opendatastructures.org/ods-java/7_1_Random_Binary_Search_Tr.html#fig:rbst-records">Open Data Structures</a>：</p><p>对每个$ x \in{0,\ldots,{n}-1} $, x所需要的搜索长度（即深度）是$ H_{x+1} + H_{n-x} - O(1) $</p><p>对每个$ x \in(-1,n)\setminus{0,\ldots,n-1} $，x所需要的搜索长度是$ H_{\lceil x \rceil} H_{n-\lceil x \rceil} $</p><h2 id="Treap-Random-BST实现"><a href="#Treap-Random-BST实现" class="headerlink" title="Treap - Random BST实现"></a>Treap - Random BST实现</h2><blockquote><p><a href="https://en.wikipedia.org/wiki/Treap">Treap-wikipedia</a></p></blockquote><p>Treap，顾名思义，就是<code>Tree</code>和<code>Head</code>的结合体，除了要满足BST的要求外，还需要满足堆的要求，即</p><ol><li><code>BST</code>: 对每个结点，左子女的值 &lt; 根的值 &lt; 右子女的值</li><li><code>Heap</code>: 对除了跟结点的每个结点，双亲结点的优先级要小于该结点的优先级</li></ol><p>所以Treap的每个结点除了包括BST结点的值value外，还需要包括一个唯一的优先级p</p><p>比如这样就是一个典型的Treap，每个结点表示为(value,p)<br><img src="http://opendatastructures.org/versions/edition-0.1e/ods-java/img1086.png" alt="Treap"></p><p>并且可以证明，由Heap的约束，最小优先级将成为根结点，而BST又保证了小于根的值将在左子树上，大于根的值在右子树</p><p>由于Heap的约束，我们可以认为Treap是按照优先级排序插入BST的，比如上述Treap可以由以下序列构造</p><p>$ (3,1), (1,6), (0,9), (5,11), (4,14), (9,17), (7,22), (6,42), (8,49), (2,99) $</p><h2 id="旋转"><a href="#旋转" class="headerlink" title="旋转"></a>旋转</h2><p>为了确保<code>Heap原则</code>，那么就需要对树进行旋转，在旋转中同时还要确保<code>BST原则</code>，比如这样的例子：</p><p><img src="http://opendatastructures.org/versions/edition-0.1e/ods-java/img1102.png" alt="BST旋转"></p><p>对w.value &lt; u.value，旋转将交换w和u的父子关系，同时将把原来的B放在新的儿子上。比如右旋，可以看作左旋和右旋是一个对称的操作</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">rotateRight</span><span class="hljs-params">(Node *u)</span> </span>&#123;<br>    Node* w = u-&gt;left;<br>    w-&gt;parent = u-&gt;parent;  <span class="hljs-comment">//parent -&gt; w</span><br>    <span class="hljs-keyword">if</span> (w-&gt;parent != <span class="hljs-literal">NULL</span>) &#123;<br>        <span class="hljs-keyword">if</span> (w-&gt;parent-&gt;left == u) &#123; <span class="hljs-comment">//u is left or right</span><br>            w-&gt;parent-&gt;left = w;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            w-&gt;parent-&gt;right = w;<br>        &#125;<br>    &#125;<br>    u-&gt;left = w-&gt;right; <span class="hljs-comment">//u.left = B</span><br>    <span class="hljs-keyword">if</span> (u-&gt;left != <span class="hljs-literal">NULL</span>) &#123;<br>        u-&gt;left-&gt;parent = u;    <span class="hljs-comment">// B.parent = u</span><br>    &#125;<br>    u-&gt;parent = w;  <span class="hljs-comment">// w.right = u</span><br>    w-&gt;right = u;<br>    <span class="hljs-keyword">if</span> (u == root) &#123;   <span class="hljs-comment">//if u is root</span><br>        root = w;<br>        root-&gt;parent = <span class="hljs-literal">NULL</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="添加-删除"><a href="#添加-删除" class="headerlink" title="添加&#x2F;删除"></a>添加&#x2F;删除</h2><ul><li>添加</li></ul><p>比如，对上述的Treap，加入一个值1.5，生成的优先级为4，即插入结点为(1.5,4)。首先使用BST的Add，插入在(2,99)的左子女上。为了满足<code>Heap规则</code>，依次进行以下旋转：</p><p>99 &gt; 4 &#x3D;&gt;右旋;<br>6 &gt; 4 &#x3D;&gt; 左旋;<br>1 &lt; 4 &#x3D;&gt; 停止;</p><p><img src="http://opendatastructures.org/versions/edition-0.1e/ods-java/img1108.png" alt="Treap插入"></p><p>由前面的引理，可以知道，旋转的次数为$ 2ln(n) + O(1) $，复杂度为$ O(logn) $</p><ul><li>删除</li></ul><p>核心基本为添加的逆操作，对上述的Treap，删除一个结果(9)，那么将删除结点(9,17)。首先使用BST的Find，找到value为9的结点，然后将以(9,17)开始，向下不断旋转，直到最终为叶结点，然后把这个叶子剪去(Cut down)。</p><p>旋转原则:</p><ol><li>left &#x3D; NULL &amp; right &#x3D; NULL ，不动</li><li><strong>left &#x3D; NULL，左旋(right &#x3D; NULL则右旋)</strong><code>注:原文这里描述写反了</code></li><li>left.p &lt; right.p，右旋(right.p &lt; left.p则左旋)</li></ol><p>依次进行以下旋转：</p><p>right &#x3D; NULL &#x3D;&gt; 右旋;<br>right &#x3D; NULL &#x3D;&gt; 右旋;<br>叶结点 &#x3D;&gt; 停止;</p><p><img src="http://opendatastructures.org/versions/edition-0.1e/ods-java/img1114.png" alt="Treap删除"></p><p>和添加相反，复杂度为$ O(logn) $</p><h2 id="复杂度"><a href="#复杂度" class="headerlink" title="复杂度"></a>复杂度</h2><p><code>构造</code>: $ O(logn) $<br><code>查找</code>: $ O(logn) $<br><code>添加</code>: $ O(logn) $<br><code>删除</code>: $ O(logn) $</p><p>虽说都是$ O(logn) $，但是对比另一种高级数据结构<a href="https://en.wikipedia.org/wiki/Skip_list">Skip List(跳表)</a>，查找复杂度在常数上有不同：</p><p><code>Skip List</code>: $ elnn + O(1) \approx 1.884log(n) + O(1) $<br><code>Treap</code>: $ 2ln(n) + O(1)  \approx 1.386log(n) + O(1) $</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><blockquote><p>完整版C++实现，这里面的随机优先级，直接使用了value当种子srand()然后rand()获取随机数……（先进行BST的Add，确保value不会重复），实际中可以采用其他随机数方式获得更好的期望复杂度<br>（吐槽……开始没注意这是Java版伪代码，以后一定用Java或者JavaScript写……指针地狱）</p></blockquote><p>代码链接：<a href="http://www.dreampiggy.com/source/413-2/">Treap</a></p>]]></content>
    
    
    <categories>
      
      <category>未分类</category>
      
    </categories>
    
    
    <tags>
      
      <tag>数据结构</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>用 C++ 写一个 Inet4Address 类</title>
    <link href="/%E7%94%A8-C-%E5%86%99%E4%B8%80%E4%B8%AA-Inet4Address-%E7%B1%BB/"/>
    <url>/%E7%94%A8-C-%E5%86%99%E4%B8%80%E4%B8%AA-Inet4Address-%E7%B1%BB/</url>
    
    <content type="html"><![CDATA[<p><code>Inet4Address</code> 在 .net 和 facebook&#x2F;folly 中也叫做 <code>IPAddress</code>。<br>（顺便黑一下，muduo 中居然把 <code>SocketAddress</code> 叫做 <code>InetAddress</code> 真是有失偏颇。</p><hr><h3 id="构造ip地址"><a href="#构造ip地址" class="headerlink" title="构造ip地址"></a>构造ip地址</h3><br/><p>ip 地址的构造，比较麻烦的地方就是网络序和主机序之间的问题。</p><p>我们的 raw ipv4 address 存储在一个 <code>uint32_t</code> 的整数中，按照 <a href="http://man7.org/linux/man-pages/man7/ip.7.html">linux 官方手册</a>中的描述，以下结构体表示 ipv4 address：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/* Internet address. */</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">in_addr</span> &#123;</span><br>    <span class="hljs-type">uint32_t</span> s_addr; <span class="hljs-comment">/* address in network byte order */</span><br>&#125;;<br></code></pre></td></tr></table></figure><p><code>s_addr</code> 是按网络序存储的，然而在下面的测试中，有与我预期不符合的地方：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-built_in">BOOST_AUTO_TEST_CASE</span>(test_byteorder_inaddr) &#123;<br>  in_addr addr;<br>  <span class="hljs-built_in">inet_pton</span>(AF_INET, <span class="hljs-string">&quot;192.168.0.1&quot;</span>, &amp;addr);<br>  <span class="hljs-built_in">BOOST_CHECK_EQUAL</span>(addr.s_addr, <span class="hljs-number">0x0100A8C0</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p>我原先以为高位的 192 应该在 b3，而实际上在 b0。在 Java 中 的 <code>Inet4Address.getAddress()</code> 也有注释说明</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Returns the raw IP address of this &#123;<span class="hljs-doctag">@code</span> InetAddress&#125;</span><br><span class="hljs-comment"> * object. The result is in network byte order: the highest order</span><br><span class="hljs-comment"> * byte of the address is in &#123;<span class="hljs-doctag">@code</span> getAddress()[0]&#125;.</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@return</span>  the raw IP address of this object.</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-type">byte</span>[] getAddress() &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>（一开始没有理解这一点，我在 s_addr 存储的是 little-endian 值，以至于<a href="https://github.com/neverchanje/sugen/blob/master/sugen/net/EndianConv.h">我引入了 redis 的 endianconv</a> 作为工具函数，现在看来暂时没有用武之地了）</p><p>我们首先规定<strong>我们将使用 big-endian 存储 IP 地址</strong>，并统一使用</p><p>对于 IP 地址：<strong>b0.b1.b2.b3</strong>，我们用</p><p><strong>0x b3 b2 b1 b0 来构造大端序</strong></p><p><strong>0x b0 b1 b2 b3 来构造小端序</strong></p><ol><li><p>我们允许使用者通过 <code>Byte4</code> 类型，也就是 <code>std::array&lt;uint8_t, 4&gt;</code> 作为参数来构造 <code>Inet4Address</code>，前提是 <code>Byte4</code> 参数是网络序：</p><p> <strong>即对于 “192.168.0.1”， b0 &#x3D; 192, b1 &#x3D; 168, b2 &#x3D; 0, b3 &#x3D; 1</strong></p></li><li><p>我们也允许使用者通过 NBO 的 <code>uint32_t</code> 类型的地址进行构造，这时候我们该用  <code>ntohl</code> 或 <code>htonl</code> 来实现。</p><hr></li></ol><h3 id="特殊的-ip-地址"><a href="#特殊的-ip-地址" class="headerlink" title="特殊的 ip 地址"></a>特殊的 ip 地址</h3><br/><ul><li><p><a href="https://github.com/neverchanje/sugen/blob/master/sugen/net/Inet4Address.h#L82">loopback address</a><br>环回地址。也就是<code>127.0.0.1</code></p></li><li><p><a href="https://github.com/neverchanje/sugen/blob/master/sugen/net/Inet4Address.h#L88">link local address</a></p></li><li><p><a href="https://github.com/neverchanje/sugen/blob/master/sugen/net/Inet4Address.h#L76">multicast address</a></p></li><li><p><a href="https://github.com/neverchanje/sugen/blob/master/sugen/net/Inet4Address.h#L96">private address</a></p></li></ul><p>这些地址在代码注释中有提供描述他们的 RFC 文档。</p><hr><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><br /><p>因为理解的偏差，造轮子的时候走了一些远路（但不是歧路）：</p><ul><li><p><code>in_addr.s_addr</code> 是否为 NBO</p></li><li><p>b0 为 ipv4 的高8位地址，而不是 b3</p></li><li><p>引入 redis 的 endianconv，写了一些无用代码，希望以后会派上用场。</p></li><li><p>当然还有阅读 RFC 文档，理解这些特殊 IP 地址的定义和用途。</p></li></ul>]]></content>
    
    
    <categories>
      
      <category>未分类</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C++</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Implementing an unique_ptr</title>
    <link href="/Implementing-an-unique-ptr/"/>
    <url>/Implementing-an-unique-ptr/</url>
    
    <content type="html"><![CDATA[<p>事实证明实现一个 unique_ptr 对其原理的认知并没有什么提升。</p><p>为了简便，我们只实现 single object 版本，不实现存储 array type 的 unique_ptr。</p><hr><p>我们首先要对 UniquePtr 的定义进行声明：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">class</span> <span class="hljs-title class_">T</span>, <span class="hljs-keyword">class</span> <span class="hljs-title class_">D</span>&gt;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">UniquePtr</span> &#123;<br></code></pre></td></tr></table></figure><p>T 是 UniquePtr 所存储的指针的类型，D 是其 Deleter 的类型，UniquePtr 在析构时调用 Deleter，从而保指针离开所在域之后即被释放，这是简单原理，不详谈。</p><p>首先是一个模板类型的细节，在实现容器类的时候常常需要用到并且注意的：<br>UniquePtr 中所存储的类型不总是 T，而是 T 及其子类，我们记作 U。于是乎，我们需要提供这样一个构造函数：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">class</span> U&gt;</span><br><span class="hljs-function"><span class="hljs-title">UniquePtr</span><span class="hljs-params">(U *ptr)</span></span>;<br></code></pre></td></tr></table></figure><p>函数的原型在 <a href="http://en.cppreference.com/w/cpp/memory/unique_ptr">cppreference&#x2F;memory&#x2F;unique_ptr</a> 中都是有提供的，所以其实实现的时候可以不用考虑设计。</p><p>然而我们要注意一个关于 Deleter 的细节：</p><blockquote><p>a) If D is non-reference type A, then the signatures are:</p><ul><li><code>unique_ptr(pointer p, const A&amp; d);</code> (requires that Deleter is nothrow-CopyConstructible)</li><li><code>unique_ptr(pointer p, A&amp;&amp; d);</code> (requires that Deleter is nothrow-MoveConstructible)</li></ul><p>b) If D is an lvalue-reference type A&amp;, then the signatures are:</p><ul><li><code>unique_ptr(pointer p, A&amp; d);</code></li><li><code>unique_ptr(pointer p, A&amp;&amp; d);</code></li></ul><p>c) If D is an lvalue-reference type const A&amp;, then the signatures are:</p><ul><li><code>unique_ptr(pointer p, const A&amp; d);</code></li><li><code>unique_ptr(pointer p, const A&amp;&amp; d);</code></li></ul></blockquote><p>由于每种情况提供两种 Deleter 类型不同的构造函数，我们将上面一种的 Deleter 类型记作 <code>del_arg1_type</code>，下面的记作 <code>del_arg2_type</code>。</p><p>我们可以轻易地整理出逻辑：如果 D 是 non-reference，则</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">typename</span> <span class="hljs-type">const</span> remove_reference&lt;D&gt;::type&amp; del_arg1_type;<br></code></pre></td></tr></table></figure><p>否则</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">typedef</span> D del_arg1_type;<br></code></pre></td></tr></table></figure><p>另一方面，<code>del_arg2_type</code> 的逻辑就很简单了：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">typename</span> remove_reference&lt;D&gt;::type &amp;&amp; del_arg2_type;<br></code></pre></td></tr></table></figure><p>这样一来，我们就解决了这部分的问题。</p>]]></content>
    
    
    <categories>
      
      <category>未分类</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C++</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>关于 boost::noncopyable 的一点思考</title>
    <link href="/%E5%85%B3%E4%BA%8E-boost-noncopyable-%E7%9A%84%E4%B8%80%E7%82%B9%E6%80%9D%E8%80%83/"/>
    <url>/%E5%85%B3%E4%BA%8E-boost-noncopyable-%E7%9A%84%E4%B8%80%E7%82%B9%E6%80%9D%E8%80%83/</url>
    
    <content type="html"><![CDATA[<p>一般通过继承 <code>boost::noncopyable</code> 来保证类的对象不会被复制。我们会采用如下写法：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Buffer</span> : boost::noncopyable &#123;<br></code></pre></td></tr></table></figure><p>注意的是，我们既可以采用公有继承 (public)，也可以采用默认继承方式 (private)，具体使用哪一种方式，需要我们的思考。</p><p>譬如，当父类拥有了 noncopyable 的特性，一般情况下，我们希望子类在继承父类的同时，也能继承其 noncopyable 的特性，于是子类就 <strong>无需重复继承 <code>boost::noncoyable</code></strong> 。举个例子：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">FixedSizeBuffer</span> : <span class="hljs-keyword">public</span> Buffer &#123;<br></code></pre></td></tr></table></figure><p>由于 <code>Buffer</code> 不应该被复制，在 <code>FixedSizeBuffer</code> 公有继承了 <code>Buffer</code>之后，我们希望 <code>FixedSizeBuffer</code> 能够 <strong>同时继承 <code>Buffer</code> 的 noncopyable 的特性</strong>。我们就不必这样写：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">FixedSizeBuffer</span> : <span class="hljs-keyword">public</span> Buffer, boost::noncopyable &#123;<br></code></pre></td></tr></table></figure><p>我们可以做到吗？</p><p>首先我们来了解 boost::noncopyable 的内部实现。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">noncopyable</span><br>&#123;<br>  <span class="hljs-keyword">protected</span>:<br>      <span class="hljs-built_in">noncopyable</span>() &#123;&#125;<br>      ~<span class="hljs-built_in">noncopyable</span>() &#123;&#125;<br>  <span class="hljs-keyword">private</span>:  <span class="hljs-comment">// emphasize the following members are private</span><br>      <span class="hljs-built_in">noncopyable</span>( <span class="hljs-type">const</span> noncopyable&amp; );<br>      noncopyable&amp; <span class="hljs-keyword">operator</span>=( <span class="hljs-type">const</span> noncopyable&amp; );<br>  &#125;;<br>&#125;<br></code></pre></td></tr></table></figure><p>这是 C++99 的版本，如果是 C++11 则会使用如下写法：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">protected</span>:<br>    <span class="hljs-built_in">noncopyable</span>( <span class="hljs-type">const</span> noncopyable&amp; ) = <span class="hljs-keyword">delete</span>;<br>    noncopyable&amp; <span class="hljs-keyword">operator</span>=( <span class="hljs-type">const</span> noncopyable&amp; ) = <span class="hljs-keyword">delete</span>;<br></code></pre></td></tr></table></figure><p>我们知道 protected 声明的成员在公有继承下依然可见，而 private 不再可见，那是否意味着 C++99 和 C++11 的两种实现有所不同？</p><hr><p>以上是我们平时的思考。如果已知答案，这些思考只是矫情跟无聊而已。</p><p>实际上，这两种方法完全相同，使用 public 继承与使用 private 继承也 <strong>完全没有任何区别</strong>。</p><p>因为子类在使用 copy constructor 和 assignment operator 的时候，必须调用父类的相应函数。显然，如果把相应函数</p><ul><li>放在 private 内，或者</li><li>放在 protected 块内，并用 <code>=delete</code> 标识；</li></ul><p>那子类即使实现了相应函数也无法成功调用。</p><hr><p>所以我们得出一个结论：只要父类继承了 <code>boost::noncopyable</code>，那么子类就无需重复继承。另一方面，我们一般使用 private 继承来为类增加功能，所以我们一般使用默认继承方式（private 继承）来继承 <code>boost::noncopyable</code>，即：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Buffer</span> : boost::noncopyable<br></code></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">FixedSizeBuffer</span> : <span class="hljs-keyword">public</span> Buffer<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>未分类</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C++</tag>
      
      <tag>Boost</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>关于 Redis 3.0 中的数据结构</title>
    <link href="/%E5%85%B3%E4%BA%8E-Redis-3-0-%E4%B8%AD%E7%9A%84%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    <url>/%E5%85%B3%E4%BA%8E-Redis-3-0-%E4%B8%AD%E7%9A%84%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/</url>
    
    <content type="html"><![CDATA[<h4 id="Redis-是什么？"><a href="#Redis-是什么？" class="headerlink" title="Redis 是什么？"></a>Redis 是什么？</h4><p>Redis 官方网站：<a href="http://redis.io/">http://redis.io/</a></p><hr><h4 id="为什么要阅读-redis-的源代码？"><a href="#为什么要阅读-redis-的源代码？" class="headerlink" title="为什么要阅读 redis 的源代码？"></a>为什么要阅读 redis 的源代码？</h4><p>等价于问题：<a href="http://www.zhihu.com/question/29852167">知乎：我们（大多数人）为什么喜欢造轮子？</a></p><p>redis 中有功能精简的模块，如 <code>anet</code>, <code>ae</code>，也有针对 redis 高度优化的数据结构模块，如 <code>ziplist</code>, <code>dict</code>, <code>intset</code> 等。这些模块相对易于学习，也非常有料。redis 本身就是一个相当优秀的开源作品，并且使用广泛，学习其中的实现，也能对 redis 有更深入的了解。</p><hr><h4 id="简单开头"><a href="#简单开头" class="headerlink" title="简单开头"></a>简单开头</h4><p>Redis 对内存效率的要求常常会高于对时间效率的要求。所以接下来我们更多地会看到 redis 针对数据结构的内存上的优化。</p><hr><h4 id="Data-Structure-1-adlist"><a href="#Data-Structure-1-adlist" class="headerlink" title="Data Structure #1: adlist"></a>Data Structure #1: <code>adlist</code></h4><p><code>adlist</code> 是 redis 实现的一个双向链表。算法原理和普通的双向链表一样。<br>但是由于 C 语言没有复制构造函数之类的东西，所以深复制的实现要靠函数指针如：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> *(*dup) (<span class="hljs-type">void</span> *ptr);<br></code></pre></td></tr></table></figure><p>与之对应的还有深释放和深匹配（自己造的词）</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> (*<span class="hljs-built_in">free</span>) (<span class="hljs-type">void</span> *ptr);<br><span class="hljs-type">int</span> (*match) (<span class="hljs-type">void</span> *ptr, <span class="hljs-type">void</span> *key);<br></code></pre></td></tr></table></figure><hr><h4 id="Data-Structure-2-intset"><a href="#Data-Structure-2-intset" class="headerlink" title="Data Structure #2: intset"></a>Data Structure #2: <code>intset</code></h4><p>首先说明， <code>intset</code> 内部由数组实现。而 <code>intset</code> 顾名思义，只能够存放整数数组。但即使是整数依然有多种类型。<code>uint32_t</code>，<code>int16_t</code>，<code>int8_t</code> 等等。</p><p>由于 C 语言不具有多态，如果要一次性存放这些类型的数组，我们可以这样：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">intset</span> &#123;</span><br>    <span class="hljs-type">uint32_t</span> *ui32;<br>    <span class="hljs-type">uint16_t</span> *ui16;<br>    <span class="hljs-type">int8_t</span>   *i8;<br>    ....<br>&#125; intset;<br></code></pre></td></tr></table></figure><p>虽然这样可以解决问题，但这显然是一种非常麻烦的方式。而且内存开销大。</p><p>redis 提供的思路是：<br>可以看出，一个 <code>int16_t</code> 可以用 2 个 <code>int8_t</code> 保存，同理地，一个 <code>int32_t</code> 可以用 4 个 <code>int8_t</code> 保存。所以，我们只需要一个 <code>int8_t[]</code> 数组即可。</p><p>我们给出结构体：</p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs angelscript"><span class="hljs-keyword">typedef</span> struct <span class="hljs-built_in">int</span><span class="hljs-keyword">set</span> &#123;<br>    <span class="hljs-built_in">uint32</span>_t encoding;<br>    <span class="hljs-built_in">uint32</span>_t length;<br>    <span class="hljs-built_in">int8</span>_t contents[];<br>&#125; <span class="hljs-built_in">int</span><span class="hljs-keyword">set</span>;<br></code></pre></td></tr></table></figure><ul><li><p>第一个问题：<strong>如何知道 <code>intset</code> 中存储的值的类型？</strong></p><p>redis 用一个 encoding 值表示 <code>intset</code> 中值的类型。</p></li><li><p>第二个问题：<strong>当值超过 <code>int8_t</code> 的范围，但在 <code>int16_t</code> 的范围内，如何对 <code>intset</code> 做出修改？</strong></p><p>重新调整 <code>contents</code> 数组的大小，以容纳 <code>length</code> 个 <code>int16_t</code> 值，并修改 <code>encoding</code> ，即：</p></li></ul><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs abnf"><span class="hljs-attribute">contents</span> <span class="hljs-operator">=</span> realloc(sizeof(int16_t) * length)<span class="hljs-comment">;`</span><br><span class="hljs-attribute">encoding</span> <span class="hljs-operator">=</span> INTSET_ENC_INT16<span class="hljs-comment">;</span><br></code></pre></td></tr></table></figure><p><code>intset</code> 本身还提供了普通的 set 应有的特性，比如 <em>有序性</em>，<em>唯一性</em></p><hr><h4 id="Data-Structure-3-ziplist"><a href="#Data-Structure-3-ziplist" class="headerlink" title="Data Structure #3: ziplist"></a>Data Structure #3: <code>ziplist</code></h4><p><code>ziplist</code> 是一个压缩的双向链表，只能储存整数和字符串</p><p>在了解之前，我们首先要理解压缩的意义。压缩的数据一定是静态的，我们很难直接对压缩的数据进行动态操作。如果要进行动态操作，首先要进行解压(decode)，等到操作结束后，再进行压缩(encode）。</p><p>回想一下，一个双向链表节点的基本结构是</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">listNode</span> &#123;</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">listNode</span> *<span class="hljs-title">prev</span>;</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">listNode</span> *<span class="hljs-title">next</span>;</span><br><span class="hljs-type">void</span>* value;<br>&#125; listNode;<br></code></pre></td></tr></table></figure><p>看起来无法压缩，其实仔细观察会发现，<code>prev</code> 和 <code>next</code> 指针都会占用 <code>8bytes</code> 的空间，可以从这里下手。</p><p>redis 提供的思路是：把整个 <code>ziplist</code> 放在一块连续的内存块上。这样就可以通过一些计算来获得 <code>next</code> 和 <code>prev</code>。</p><p>假设指向当前节点的指针 <code>p</code>，当前节点的内存长度 <code>len</code>，那么下一个节点的指针 <code>next</code> 显然是：</p><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ini"><span class="hljs-attr">next</span> = p + len<span class="hljs-comment">;</span><br></code></pre></td></tr></table></figure><p>如果要获取 <code>prev</code>，则还要存储前一个节点的内存长度 <code>prevlen</code>，然后计算：</p><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs abnf"><span class="hljs-attribute">prev</span> <span class="hljs-operator">=</span> p - prevlen<span class="hljs-comment">;</span><br></code></pre></td></tr></table></figure><p>所以我们可以由此设计出 <code>listNode</code> 内存块的分配</p><figure class="highlight gherkin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs gherkin">|<span class="hljs-string">prevlensize</span>|<span class="hljs-string">prevlen</span>|<span class="hljs-string">lensize</span>|<span class="hljs-string">len</span>|<span class="hljs-string">value</span>|<br></code></pre></td></tr></table></figure><p>由于 <code>prevlen</code> 和 <code>len</code> 都是根据值的大小分配不同内存的（如果值小于 <code>int8_t</code> 就只会分配 <code>1byte</code>），我们就用固定长度为 <code>1byte</code> 的 <code>prevlensize</code> 和 <code>lensize</code> 来保存 <code>prevlen</code> 和 <code>len</code> 所花费的内存大小。</p><p>这样根据值的大小来动态分配值的内存空间，从而达到节约内存的目的，是 redis 常用的一种手段。</p><p>这只是大概思路，具体实现还要考虑到很多细节，比较麻烦。</p><hr><h4 id="Data-Structure-4-zipmap"><a href="#Data-Structure-4-zipmap" class="headerlink" title="Data Structure #4: zipmap"></a>Data Structure #4: <code>zipmap</code></h4><p>与 <code>ziplist</code> 用的几乎是同样一种手段。<code>zipmap</code> 是一个压缩的 string key-value 数组。获取 value 的复杂度是 O(n) 的，因此适合数据不多的场合。</p><p>key-value 节点的结构是</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">klen</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">key</span>&gt;</span>|<span class="hljs-tag">&lt;<span class="hljs-name">vlen</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">free</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">value</span>&gt;</span><br>----key----|-------value-------<br></code></pre></td></tr></table></figure><ul><li>Question：<strong>free 区有什么作用？</strong></li></ul><p>这要牵扯到 redis 处理内存和时间平衡的一个技巧。</p><p>我们储存一个值 <code>value</code>，并为其分配长度为 <code>len</code> 的空间，这个值在动态改变的时候，占用的内存可能会变为 <code>newlen</code>。 如果 <code>newlen &lt; len</code> ，意味着我们会多余出一些空间，这个空间记作 <code>free</code>。我们接下来可能要做两种操作：</p><ul><li>用 <code>realloc</code> 搭配 <code>memmove</code> 等操作将内存空间减少至 <code>newlen</code></li><li>将这段多余的空间暂且放着，作为一段 <code>free</code> 空间。</li></ul><p>从时间效率考虑，后者肯定是最优的。（感觉解释起来有点麻烦）。但从内存效率考虑，前者肯定是最优的。</p><p>根据具体情况，我们可能只考虑前者（不考虑内存），或只考虑后者（时间要求不高），也可以综合考虑，设置一个参数 <code>MAX_FREE_VALUE</code> 表示最大能够容忍的 <code>free</code> 空间。如果超过了 <code>MAX_FREE_VALUE</code> 我们就把 <code>free</code> 空间腾出来。如果没超过，就暂且放着这块 <code>free</code> 空间。</p><hr><h4 id="Data-Structure-5-dict"><a href="#Data-Structure-5-dict" class="headerlink" title="Data Structure #5: dict"></a>Data Structure #5: <code>dict</code></h4><p>跟普通的 Hashtable 差不多，普通的 Hashtable 实现可参照 <code>java.util.Hashtable&lt;K,V&gt;</code></p><p>redis 中的 dict 进行了优化，也更复杂：</p><ul><li><p>一个 dict 其实维护了两个 Hashtable</p><p>在 rehash 操作时，我们要进行 Hashtable 的迁移工作，这时候其实可以让两个 Hashtable 一起工作。比如查找节点时，在表1中找不到，则去表2中找。这样允许我们可以不必在 rehash 的时候一次性完成全部的迁移。</p></li><li><p>渐进式 rehash</p><p><em><strong>为什么要使用渐进式 rehash ？</strong></em></p><p>显然，rehash 操作是整个 hashtable 的瓶颈。可以采用分摊的思想，将 rehash 操作分摊给其他操作。比如分摊给 dictAdd, dictFind, dictDelete, dictReplace。由于这些操作平均复杂度都是 O(1) 的，所以每个操作都只能分摊一次 rehash 操作。</p></li></ul>]]></content>
    
    
    <categories>
      
      <category>未分类</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Redis</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>I++俱乐部</title>
    <link href="/I-%E4%BF%B1%E4%B9%90%E9%83%A8/"/>
    <url>/I-%E4%BF%B1%E4%B9%90%E9%83%A8/</url>
    
    <content type="html"><![CDATA[<p>&amp;&emsp;&emsp;东南大学江宁区九龙湖校区南门软件学院，当年我的好基友总是说我不是在学院就是在去学院的路上。<br>&emsp;&emsp;真的，多年前的软件学院那是一个怎样的存在，整层楼6间不用抢座宽敞明亮的自习教室，再来一层楼6间不用抢座宽敞明亮的机房，再来一排各式供社团使用的独立工作室，4层楼每层楼梯转角有乒乓球桌；自习室机房和工作室各式该有的网电空调工位齐全；1楼设有专用的图书室和文娱室；门外立着闪亮的东南大学软件学院的招牌。这样一个高大上的独立软院楼配上300多人每人4倍学费的学院，作为当时学院的一名学生，这样的求学环境真的够炫酷。<br>&emsp;&emsp;可那又怎么样呢。那时的IT业也没现在这么热，软院也只是一个在学校官网上拉到页面最下面点倒数第几个连接的学院。同年级的同学绝大都是调剂专业而来的学生，带着各式的不满，只要上下课做作业考试、魔兽、Dota、LOL就可以轻易用掉大学4年。优秀的同学们带着优秀的惯性，继续钻研着各门课程科目，刷个前百分之几的绩点可以保研。并没有很多人真正关心就读于这个专业是为了做什么。学院楼其实也只是一个空架子，除了某些课程使用机房或是自习教室时强制学生过来。其它时间里特别是周末里我甚至可以在空荡荡的楼层间漫步，然后独占一个机房教室或者工作室。<br>&emsp;&emsp;这才不是我想要的软件学院。读高中的时候我沉迷游戏有网瘾，玩魔兽地图编辑器，觉得制作一个游戏能创造一个自己的世界，简直是世界上最棒的事。所以猜想软件工程正是同样的，是最接近能创造一个世界的学科。所以为了在混学位和刷绩点之外，在大学里聚集更多不同的价值观的同学们，先是成立了中二病性质的，The9th软院游戏制作社，初期专教制作魔兽地图后期教写C++游戏，后又与一个接学校内部小网站开发的叫WE的俱乐部，合并成为I++俱乐部。（这里爆一点黑历史，The9th这个名字是创始人说电子游戏是一种人类八大艺术形式之外的第九类艺术，WE这个名字是说这个俱乐部的创始人有11个，We have Eleven people)。<br>&emsp;&emsp;I++的名字是大家一起选的，i++也是编程当中最常写的一段代码，表示一点一点的增加有积累和进步，配合了新俱乐部的目标，就是大家能在这里随性地一起研究学习的任何感兴趣的IT技术，一起组队做软件开发项目，参加国内外各式开发比赛，努力在专业上积累和提升自己的动手能力（不知不觉这么官腔哟）。所以正是那句话，如果有一天你觉得这不是你想要的大学生活，就来I++看看吧，也许真能找到和你一样想法的同伴，一起来努力做点什么不一样的事。</p>]]></content>
    
    
    <categories>
      
      <category>未分类</category>
      
    </categories>
    
    
  </entry>
  
  
  
  
  
  
  <entry>
    <title>I++ 俱乐部</title>
    <link href="/"/>
    <url>/</url>
    
    <content type="html"><![CDATA[<h3 id="我们是谁"><a href="#我们是谁" class="headerlink" title="我们是谁"></a>我们是谁</h3><p>2015 常驻用户</p><p>吴涛</p><p>2016 常驻用户</p><p>吕炀</p><p><img src="/img/people/lvyang.jpg" alt="LvYang"></p><p>2024 常驻用户</p><p>何山</p><h3 id="联系我们"><a href="#联系我们" class="headerlink" title="联系我们"></a>联系我们</h3><p>I++ 俱乐部是东南大学计软智学院的技术俱乐部。南京江宁区东南大学九龙湖校区计算机拔尖基地。</p>]]></content>
    
  </entry>
  
  
  
</search>
